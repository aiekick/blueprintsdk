#include <UI.h>
#include <BuildInNodes.h> // Which is generated by cmake
#include <imgui_node_editor_internal.h>
#include <iomanip>
#include <utility>
#define THUMBNAIL_COUNT     100
#define THUMBNAIL_HIDDEN    30
#define DEBUG_NODE_DRAWING  0
#define DEBUG_GROUP_NODE    0
extern std::mutex g_Mutex;

inline string to_lower(string s) 
{        
    for(char &c : s)
        c = tolower(c);
    return s;
}

const string titlebar_icons[] = {ICON_NODE_COPY, ICON_NODE_DELETE, ICON_NODE_SETTING, ICON_SAVE_BLUEPRINT};
                                //{"c", "d", "s", "S"};

namespace BluePrint
{
BluePrintStyle BPStyleFromName(string name)
{
    if (name.compare("Default") == 0)
        return BluePrintStyle::BP_Style_BluePrint;
    else if (name.compare("Light") == 0)
        return BluePrintStyle::BP_Style_Light;
    else if (name.compare("Mono") == 0)
        return BluePrintStyle::BP_Style_Mono;
    else if (name.compare("Custom") == 0)
        return BluePrintStyle::BP_Style_Custom;
    else
        return BluePrintStyle::BP_Style_BluePrint;
}

string BPStyleToString(BluePrintStyle style)
{
    switch (style)
    {
        default:                                return "Default";
        case BluePrintStyle::BP_Style_BluePrint:return "Default";
        case BluePrintStyle::BP_Style_Light:    return "Light";
        case BluePrintStyle::BP_Style_Mono:     return "Mono";
        case BluePrintStyle::BP_Style_Custom:   return "Custom";
    }
}
// ---------------------------
// ------[ ContextMenu ]------
// ---------------------------
void ContextMenu::Open(void)
{
    ImGui::OpenPopup("##context-menu");
}

void ContextMenu::Show(BluePrintUI& UI)
{
    if (!ImGui::IsPopupOpen("##context-menu"))
        return;

    //auto blueprint = &UI.m_Document->m_Blueprint;
    auto menuAction = [](Action& action)
    {
#if IMGUI_ICONS
        string ItemTitle = action.GetIcon() + " " + action.GetName();
#else
        string ItemTitle = action.GetName();
#endif
        if (ImGui::MenuItem(ItemTitle.c_str(), nullptr, nullptr, action.IsEnabled()))
        {
            action.Execute();
        }
    };
    if (ImGui::BeginPopup("##context-menu"))
    {
        auto popupPosition = ImGui::GetMousePosOnOpeningCurrentPopup();
        UI.m_PopupMousePos = popupPosition;
        menuAction(UI.m_File_Open);
        ImGui::Separator();
        menuAction(UI.m_File_Import);
        ImGui::Separator();
        if (!UI.m_isChildWindow)
        {
            auto mostRecentlyOpenFiles = ImGui::MostRecentlyUsedList("BluePrintOpenList");
            if (ImGui::BeginMenu(ICON_NODE_OPEN " Open Recent...", !mostRecentlyOpenFiles.GetList().empty()))
            {
                for (auto& entry : mostRecentlyOpenFiles.GetList())
                {
                    string title = string(ICON_NODE_FILE) + " " + entry;
                    if (ImGui::MenuItem(title.c_str()))
                    {
                        UI.File_Open(entry.c_str());
                    }
                }
                ImGui::Separator();
                if (ImGui::MenuItem(ICON_NODE_CLEAR " Clear Recently Opened"))
                    mostRecentlyOpenFiles.Clear();
                ImGui::EndMenu();
            }
            ImGui::Separator();
        }
        if (ImGui::BeginMenu(ICON_BLUEPRINT_STYLE " Set Style"))
        {
            ImGui::Bullet();
            if (ImGui::MenuItem("Default##BluePrintStyle"))
            {
                UI.SetStyle(BluePrintStyle::BP_Style_BluePrint);
                ed::SetTheme(BPStyleToString(BluePrintStyle::BP_Style_BluePrint));
            }
            ImGui::Bullet();
            if (ImGui::MenuItem("Light##BluePrintStyle"))
            {
                UI.SetStyle(BluePrintStyle::BP_Style_Light);
                ed::SetTheme(BPStyleToString(BluePrintStyle::BP_Style_Light));
            }
            ImGui::Bullet();
            if (ImGui::MenuItem("Mono##BluePrintStyle"))
            {
                UI.SetStyle(BluePrintStyle::BP_Style_Mono);
                ed::SetTheme(BPStyleToString(BluePrintStyle::BP_Style_Mono));
            }
            ImGui::EndMenu();
        }
        ImGui::Separator();
        menuAction(UI.m_File_New);
        ImGui::Separator();
        menuAction(UI.m_File_Save);
        ImGui::Separator();
        menuAction(UI.m_File_SaveAs);
        ImGui::Separator();
        menuAction(UI.m_View_ShowFlow);
        ImGui::Separator();
        menuAction(UI.m_View_ZoomToContent);
        ImGui::Separator();
        menuAction(UI.m_View_ZoomToSelection);
        ImGui::Separator();
        menuAction(UI.m_View_ShowMeters);
        ImGui::Separator();
        if (ImGui::BeginMenu(ICON_NEW_NODE " Add Node"))
        {
            UI.CleanStateStorage();
            UI.ShowNewNodeMenu(popupPosition);
            ImGui::EndMenu();
        }
        ImGui::EndPopup();
    }
}

// ---------------------------
// ----[ NodeContextMenu ]----
// ---------------------------
void NodeContextMenu::Open(Node* node/* = nullptr*/)
{
    ImGui::GetStateStorage()->SetVoidPtr(ImGui::GetID("##node-context-menu-node"), node);
    ImGui::OpenPopup("##node-context-menu");
}

void NodeContextMenu::Show(BluePrintUI& UI)
{
    if (!ImGui::IsPopupOpen("##node-context-menu"))
        return;
    //auto blueprint = &UI.m_Document->m_Blueprint;
    auto storage = ImGui::GetStateStorage();
    auto node = reinterpret_cast<Node*>(storage->GetVoidPtr(ImGui::GetID("##node-context-menu-node")));
    if (!node)
        return;
    ed::ClearSelection();
    ed::SelectNode(node->m_ID);
    auto menuAction = [](Action& action)
    {
        if (ImGui::MenuItem((action.GetIcon() + " " + action.GetName()).c_str(), nullptr, nullptr, action.IsEnabled()))
        {
            action.Execute();
        }
    };
    if (ImGui::BeginPopup("##node-context-menu"))
    {
        menuAction(UI.m_Edit_Cut);
        ImGui::Separator();
        menuAction(UI.m_Edit_Copy);
        ImGui::Separator();
        menuAction(UI.m_Edit_Duplicate);
        ImGui::Separator();
        menuAction(UI.m_Edit_Delete);
        //if (node->HasSetting())
        //{
        //    ImGui::Separator();
        //    menuAction(UI.m_Edit_Setting);
        //}
        if (node->GetStyle() == NodeStyle::Default)
        {
            ImGui::Separator();
            menuAction(UI.m_Blueprint_BreakPoint);
        }
        ImGui::Separator();
        node->DrawMenuLayout(ImGui::GetCurrentContext());
        ImGui::EndPopup();
    }
}

// --------------------------
// ----[ PinContextMenu ]----
// --------------------------

void PinContextMenu::PinContextMenu::Open(Pin* pin /*= nullptr*/)
{
    ImGui::GetStateStorage()->SetVoidPtr(ImGui::GetID("##pin-context-menu-pin"), pin);
    ImGui::OpenPopup("##pin-context-menu");
}

void PinContextMenu::PinContextMenu::Show(BluePrintUI& UI)
{
    if (!ImGui::IsPopupOpen("##pin-context-menu"))
        return;

    auto storage = ImGui::GetStateStorage();
    auto pin = reinterpret_cast<Pin*>(storage->GetVoidPtr(ImGui::GetID("##pin-context-menu-pin")));
    if (!pin)
        return;
    /*
    if (ImGui::BeginPopup("##pin-context-menu"))
    {
        ImGui::Bullet();
        if (ImGui::MenuItem("Export", "", &pin->m_Exported))
        {
            ed::SetPinChanged(pin->m_ID);
            UI.m_Document->m_IsModified = true;
        }
        ImGui::EndPopup();
    }
    */
}

// ---------------------------
// ----[ LinkContextMenu ]----
// ---------------------------
void LinkContextMenu::Open(Pin* pin /*= nullptr*/)
{
    // check link is linked with export pin, we don't allow break export link
    if (pin->IsLinkedExportedPin())
        return;

    ImGui::GetStateStorage()->SetVoidPtr(ImGui::GetID("##link-context-menu-pin"), pin);
    ImGui::OpenPopup("##link-context-menu");
}

void LinkContextMenu::Show(BluePrintUI& UI)
{
    if (!ImGui::IsPopupOpen("##link-context-menu"))
        return;

    BP* blueprint = &UI.m_Document->m_Blueprint;
    auto storage = ImGui::GetStateStorage();
    auto pin = reinterpret_cast<Pin*>(storage->GetVoidPtr(ImGui::GetID("##link-context-menu-pin")));
    if (ImGui::BeginPopup("##link-context-menu"))
    {
        if (ImGui::MenuItem("Break Link"))
        {
            if (pin && !ed::IsLinkSelected(pin->m_ID))
            {
                ed::DeleteLink(pin->m_ID);
            }
            else
            {
                auto selectedLinks = GetSelectedLinks(blueprint);
                for (auto selectedLink : selectedLinks)
                    ed::DeleteLink(selectedLink->m_ID);
            }
            UI.m_Document->m_IsModified = true;
        }

        ImGui::EndPopup();
    }
}

// ----------------------------
// ----[ NodeSettingDialog ]----
// ----------------------------
void NodeSettingDialog::Open(Node* node)
{
    ImGui::GetStateStorage()->SetVoidPtr(ImGui::GetID("##setting-node"), node);
    ImGui::OpenPopup("##setting_node_dialog");
}

void NodeSettingDialog::Show(BluePrintUI& UI)
{
    if (!ImGui::IsPopupOpen("##setting_node_dialog"))
        return;
    
    auto storage = ImGui::GetStateStorage();
    auto node = reinterpret_cast<Node*>(storage->GetVoidPtr(ImGui::GetID("##setting-node")));
    if (!node)
        return;
    ImGuiIO& io = ImGui::GetIO(); (void)io;
    ImVec2 center = ImGui::GetWindowViewport()->GetCenter();
    ImGui::SetNextWindowPos(center, ImGuiCond_Appearing, ImVec2(0.5f, 0.5f));
    if (ImGui::BeginPopupModal("##setting_node_dialog", NULL, ImGuiWindowFlags_AlwaysAutoResize | ImGuiWindowFlags_NoSavedSettings))
    {
        ImGui::Text("Setting"); ImGui::SameLine();
        ImGui::Text("%" PRI_node "\n", FMT_node(node));
        ImGui::Separator();
        node->DrawSettingLayout(ImGui::GetCurrentContext());
        ImGui::Separator();
        if (ImGui::Button("OK", ImVec2(120, 0))) 
        {
            UI.m_Document->m_IsModified = true;
            ed::SetNodeChanged(node->m_ID);
            ImGui::CloseCurrentPopup();
            if (UI.m_CallBacks.BluePrintOnChanged)
            {
                UI.m_CallBacks.BluePrintOnChanged(BP_CB_SETTING_CHANGED, UI.m_Document->m_Name, UI.m_UserHandle);
            }
        }
        ImGui::EndPopup();
    }
}

// ----------------------------
// ----[ NodeDeleteDialog ]----
// ----------------------------
void NodeDeleteDialog::Open(Node* node /* = nullptr */)
{
    ImGui::GetStateStorage()->SetVoidPtr(ImGui::GetID("##delete-node"), node);
    ImGui::OpenPopup("##delete_node_dialog");
}

void NodeDeleteDialog::Show(BluePrintUI& UI)
{
    if (!ImGui::IsPopupOpen("##delete_node_dialog"))
        return;
    
    auto storage = ImGui::GetStateStorage();
    auto node = reinterpret_cast<Node*>(storage->GetVoidPtr(ImGui::GetID("##delete-node")));
    if (!node)
        return;
    ImGuiIO& io = ImGui::GetIO(); (void)io;
    ImVec2 center = ImGui::GetWindowViewport()->GetCenter();
    ImGui::SetNextWindowPos(center, ImGuiCond_Appearing, ImVec2(0.5f, 0.5f));
    if (ImGui::BeginPopupModal("##delete_node_dialog", NULL, ImGuiWindowFlags_AlwaysAutoResize | ImGuiWindowFlags_NoSavedSettings))
    {
        ImGui::TextUnformatted("Delete Node"); ImGui::SameLine(); ImGui::Text("%" PRI_node " ?\n", FMT_node(node));
        ImGui::Separator();
        if (ImGui::Button("OK", ImVec2(120, 0))) 
        {
            ed::DeleteNode(node->m_ID);
            UI.m_Document->m_IsModified = true;
            ImGui::CloseCurrentPopup();
        }
        ImGui::SetItemDefaultFocus();
        ImGui::SameLine();
        if (ImGui::Button("Cancel", ImVec2(120, 0))) { ImGui::CloseCurrentPopup(); }
        ImGui::EndPopup();
    }
}

void NodeCreateDialog::Open(Pin* fromPin, uint32_t flag)
{
    ImGui::GetStateStorage()->SetVoidPtr(ImGui::GetID("##create_node_pin"), fromPin);
    if ((flag & BluePrintFlag::BluePrintFlag_Filter) != 0)
    {
        ImGui::OpenPopup("##create_filter_node");
    }
    else if ((flag & BluePrintFlag::BluePrintFlag_Fusion) != 0)
    {
        ImGui::OpenPopup("##create_fusion_node");
    }
    else if ((flag & BluePrintFlag::BluePrintFlag_System) != 0)
    {
        ImGui::OpenPopup("##create_system_node");
    }
    else
    {
        ImGui::OpenPopup("##create_node");
    }
}

void NodeCreateDialog::Show(BluePrintUI& UI)
{
    std::string create_node_label = "";
    std::string catalog_filter = "";
    if (!ImGui::IsPopupOpen("##create_node") &&
        !ImGui::IsPopupOpen("##create_filter_node") &&
        !ImGui::IsPopupOpen("##create_fusion_node") &&
        !ImGui::IsPopupOpen("##create_system_node"))
    {
        UI.m_isNewNodePopuped = false;
        UI.m_newNodeLinkPin = nullptr;
        return;
    }

    if (ImGui::IsPopupOpen("##create_node"))
    {
        create_node_label = "##create_node";
    }
    else if (ImGui::IsPopupOpen("##create_filter_node"))
    {
        create_node_label = "##create_filter_node";
        catalog_filter = "Filter";
        if (!UI.m_Document->m_CatalogFilter.empty())
        {
            catalog_filter += "#" + UI.m_Document->m_CatalogFilter;
        }
    }
    else if (ImGui::IsPopupOpen("##create_fusion_node"))
    {
        create_node_label = "##create_fusion_node";
        catalog_filter = "Fusion";
        if (!UI.m_Document->m_CatalogFilter.empty())
        {
            catalog_filter += "#" + UI.m_Document->m_CatalogFilter;
        }
    }
    else if (ImGui::IsPopupOpen("##create_system_node"))
    {
        create_node_label = "##create_system_node";
        catalog_filter = "System";
    }

    auto storage = ImGui::GetStateStorage();
    auto fromPin = reinterpret_cast<Pin*>(storage->GetVoidPtr(ImGui::GetID("##create_node_pin")));
    
    if (!ImGui::BeginPopup(create_node_label.c_str()))
    {
        UI.m_isNewNodePopuped = false;
        UI.m_newNodeLinkPin = nullptr;
        return;
    }
    
    auto popupPosition = ImGui::GetMousePosOnOpeningCurrentPopup();
    auto node = UI.ShowNewNodeMenu(popupPosition, catalog_filter);
    if (node)
    {
        m_CreatedNode = node;
        m_CreatedLinks.clear();
        if (fromPin)
        {
            auto newLinks = CreateLinkToFirstMatchingPin(*node, *fromPin);
            for (auto startPin : newLinks)
            {
                LOGI("[NodeCreateDialog] %" PRI_pin "  linked with %" PRI_pin, FMT_pin(startPin), FMT_pin(startPin->GetLink()));
                if (UI.m_CallBacks.BluePrintOnChanged)
                {
                    auto ret = UI.m_CallBacks.BluePrintOnChanged(BP_CB_Link, UI.m_Document->m_Name, UI.m_UserHandle);
                    if (startPin->m_Type == PinType::Flow && ret == BP_CBR_AutoLink)
                    {
                        auto out_pin = startPin->m_Node->GetAutoLinkOutputDataPin();
                        auto in_pin = startPin->GetLink()->m_Node->GetAutoLinkInputDataPin();
                        if (in_pin.size() > 0 && out_pin.size() > 0 && in_pin.size() == out_pin.size())
                        {
                            for (int i = 0; i < in_pin.size(); i++)
                            {
                                in_pin[i]->LinkTo(*out_pin[i]);
                            }
                        }
                    }
                }
            }
        }
        ed::SetNodeChanged(node->m_ID);
    }
    ImGui::EndPopup();
}

std::vector<Pin*> NodeCreateDialog::CreateLinkToFirstMatchingPin(Node& node, Pin& fromPin)
{
    for (auto nodePin : node.GetInputPins())
    {
        if (nodePin->LinkTo(fromPin))
            return { nodePin };
        if (fromPin.LinkTo(*nodePin))
            return { &fromPin };
    }
    for (auto nodePin : node.GetOutputPins())
    {
        if (nodePin->LinkTo(fromPin))
            return { nodePin };
        if (fromPin.LinkTo(*nodePin))
            return { &fromPin };
    }
    return {};
}
} // namespace BluePrint

namespace BluePrint
{
BluePrintUI::BluePrintUI()
{
    m_StyleColors[BluePrintStyleColor_TitleBg]              = ImColor(255, 255, 255,  64);
    m_StyleColors[BluePrintStyleColor_TitleBgDummy]         = ImColor(255,   0,   0,  64);
    m_StyleColors[BluePrintStyleColor_GroupBg]              = ImColor(128, 128, 128, 128);
    m_StyleColors[BluePrintStyleColor_Border]               = ImColor(255, 255, 255,  64);
    m_StyleColors[BluePrintStyleColor_DummyBorder]          = ImColor(255,   0,  32, 200);
    m_StyleColors[BluePrintStyleColor_ToolButton]           = ImColor(255, 255, 255,   0);
    m_StyleColors[BluePrintStyleColor_ToolButtonActive]     = ImColor(192, 192, 192, 192);
    m_StyleColors[BluePrintStyleColor_ToolButtonHovered]    = ImColor(192, 192, 255, 128);
    m_StyleColors[BluePrintStyleColor_DebugCurrentNode]     = ImColor(  0, 255,   0, 128);
    m_StyleColors[BluePrintStyleColor_DebugNextNode]        = ImColor(  0,   0, 255, 128);
    m_StyleColors[BluePrintStyleColor_DebugBreakPointNode]  = ImColor(255,   0,   0, 128);
    m_StyleColors[BluePrintStyleColor_PinVoid]              = ImColor(255, 255, 255, 255);
    m_StyleColors[BluePrintStyleColor_PinAny]               = ImColor(255, 255, 255, 255);
    m_StyleColors[BluePrintStyleColor_PinFlow]              = ImColor(255, 255, 255, 255);
    m_StyleColors[BluePrintStyleColor_PinBool]              = ImColor( 48, 48,  220, 255);
    m_StyleColors[BluePrintStyleColor_PinInt32]             = ImColor( 68, 201, 156, 255);
    m_StyleColors[BluePrintStyleColor_PinInt64]             = ImColor(100,  34,  78, 255);
    m_StyleColors[BluePrintStyleColor_PinFloat]             = ImColor(147, 226,  74, 255);
    m_StyleColors[BluePrintStyleColor_PinDouble]            = ImColor( 72, 113,  37, 255);
    m_StyleColors[BluePrintStyleColor_PinString]            = ImColor(124,  21, 153, 255);
    m_StyleColors[BluePrintStyleColor_PinPoint]             = ImColor(220, 110,  10, 255);
    m_StyleColors[BluePrintStyleColor_PinVector]            = ImColor( 72, 110, 220, 255);
    m_StyleColors[BluePrintStyleColor_PinMat]               = ImColor(220,  21,  21, 255);
    m_StyleColors[BluePrintStyleColor_PinCustom]            = ImColor(208,  64,  64, 255);
}

void BluePrintUI::Initialize(const char * bp_file, const char * plugin_path)
{    
    ImGui::MostRecentlyUsedList::Install(ImGui::GetCurrentContext());

#if !defined(__EMSCRIPTEN__)
    m_Config.SettingsFile = nullptr;
#endif
    InstallDocumentCallbacks();
    m_Editor = ed::CreateEditor(&m_Config);
    ed::SetCurrentEditor(m_Editor);
    m_Document = make_unique<BluePrint::Document>();
    m_Document->m_UserData = this;

    // load dynamic node
    auto nodeRegistry = m_Document->m_Blueprint.GetNodeRegistry();
    std::string plugin_real_path = plugin_path ? std::string(plugin_path) : "";
    std::vector<std::string> plugins, plugin_names;
    std::vector<std::string> node_filter = {"node"};
    std::vector<std::string> pin_filter = {"pin"};
    if (DIR_Iterate(plugin_real_path, plugins, plugin_names, node_filter, false) == 0)
    {
        LOGI("Load Extra Node %s", plugin_real_path.c_str());
        for (auto node_path : plugins)
        {
            auto nodetypeid = nodeRegistry->RegisterNodeType(node_path, &m_Document->m_Blueprint);
            if (nodetypeid == 0)
            {
                LOGE("Load Extra Node Failed %s", node_path.c_str());
                continue;
            }
            auto nodeinfo = nodeRegistry->GetTypeInfo(nodetypeid);
            if (!nodeinfo)
            {
                LOGE("Load Extra Node Failed %s", node_path.c_str());
                continue;
            }
            LOGI("Load Extra Node %s(%d.%d.%d.%d)", nodeinfo->m_NodeTypeName.c_str(),
                                                    VERSION_MAJOR(nodeinfo->m_Version), 
                                                    VERSION_MINOR(nodeinfo->m_Version), 
                                                    VERSION_PATCH(nodeinfo->m_Version), 
                                                    VERSION_BUILT(nodeinfo->m_Version));
        }
    }

    // load dynamic pin
    auto pinexRegistry = m_Document->m_Blueprint.GetPinExRegistry();
    plugins.clear(); plugin_names.clear();
    if (DIR_Iterate(plugin_real_path, plugins, plugin_names, pin_filter, false) == 0)
    {
        LOGI("Load Extra PinEx %s", plugin_real_path.c_str());
        for (auto pinex_path : plugins)
        {
            auto pPinexType = pinexRegistry->RegisterPinEx(pinex_path);
            if (pPinexType == nullptr) {
                LOGE("FAILED to load PinEx from '%s'!", pinex_path.c_str());
                continue;
            }
            LOGI("Successfully loaded PinEx from '%s'!", pinex_path.c_str());
        }
    }
    if (bp_file)
    {
        if (m_Document->Load(bp_file) != BP_ERR_NONE)
            CreateNewDocument();
    }

    if (bp_file) m_Document->SetPath(bp_file);
    m_Document->OnMakeCurrent();

    m_DebugOverlay = new DebugOverlay();
    m_DebugOverlay->Init(&m_Document->m_Blueprint);
    std::string theme = ed::GetTheme();
    SetStyle(BPStyleFromName(theme));
    ed::SetCurrentEditor(nullptr);
    InitFileDialog();
#if !defined(__EMSCRIPTEN__)
    m_ClipBoard.clear();
#endif
}

void BluePrintUI::Finalize()
{
    ed::SetCurrentEditor(m_Editor);
    if (m_Document) m_Document->Save();
    m_Document = nullptr;
    ed::SetCurrentEditor(nullptr);
    ed::DestroyEditor(m_Editor);
    m_Editor = nullptr;
    if (m_DebugOverlay) { delete m_DebugOverlay; m_DebugOverlay = nullptr; }
#ifdef USE_BOOKMARK
	// save bookmarks
	std::ofstream configFileWriter(m_BookMarkPath, std::ios::out);
	if (!configFileWriter.bad())
	{
		configFileWriter << m_FileDialog.SerializeBookmarks();
		configFileWriter.close();
	}
#endif
}

void BluePrintUI::SetStyle(enum BluePrintStyle style)
{
    auto& io = ImGui::GetIO();
    switch (style)
    {
        case BluePrintStyle::BP_Style_BluePrint:
        {
            ImGui::StyleColorsDark();
            if (m_Document) m_Document->m_Blueprint.SetStyleLight(false);
            m_FileDialog.SetDarkStyle();
            m_StyleColors[BluePrintStyleColor_TitleBg]              = ImColor(255, 255, 255,  64);
            m_StyleColors[BluePrintStyleColor_TitleBgDummy]         = ImColor(255,   0,   0,  64);
            m_StyleColors[BluePrintStyleColor_GroupBg]              = ImColor(128, 128, 128, 128);
            m_StyleColors[BluePrintStyleColor_Border]               = ImColor(255, 255, 255,  64);
            m_StyleColors[BluePrintStyleColor_DummyBorder]          = ImColor(255,   0,  32, 200);
            m_StyleColors[BluePrintStyleColor_ToolButton]           = ImColor(255, 255, 255,   0);
            m_StyleColors[BluePrintStyleColor_ToolButtonActive]     = ImColor(192, 192, 192, 192);
            m_StyleColors[BluePrintStyleColor_ToolButtonHovered]    = ImColor(192, 192, 255, 128);
            m_StyleColors[BluePrintStyleColor_DebugCurrentNode]     = ImColor(  0, 255,   0, 128);
            m_StyleColors[BluePrintStyleColor_DebugNextNode]        = ImColor(  0,   0, 255, 128);
            m_StyleColors[BluePrintStyleColor_DebugBreakPointNode]  = ImColor(255,   0,   0, 128);
            m_StyleColors[BluePrintStyleColor_PinVoid]              = ImColor(255, 255, 255, 255);
            m_StyleColors[BluePrintStyleColor_PinAny]               = ImColor(255, 255, 255, 255);
            m_StyleColors[BluePrintStyleColor_PinFlow]              = ImColor(255, 255, 255, 255);
            m_StyleColors[BluePrintStyleColor_PinBool]              = ImColor( 48, 48,  220, 255);
            m_StyleColors[BluePrintStyleColor_PinInt32]             = ImColor( 68, 201, 156, 255);
            m_StyleColors[BluePrintStyleColor_PinInt64]             = ImColor(100,  34,  78, 255);
            m_StyleColors[BluePrintStyleColor_PinFloat]             = ImColor(147, 226,  74, 255);
            m_StyleColors[BluePrintStyleColor_PinDouble]            = ImColor( 72, 113,  37, 255);
            m_StyleColors[BluePrintStyleColor_PinString]            = ImColor(124,  21, 153, 255);
            m_StyleColors[BluePrintStyleColor_PinPoint]             = ImColor(220, 110,  10, 255);
            m_StyleColors[BluePrintStyleColor_PinVector]            = ImColor( 72, 110, 220, 255);
            m_StyleColors[BluePrintStyleColor_PinMat]               = ImColor(220,  64,  64, 255);
            m_StyleColors[BluePrintStyleColor_PinCustom]            = ImColor(208,  64,  64, 255);
            auto& editorStyle = ed::GetStyle();
            editorStyle.Colors[ed::StyleColor_Bg]           = ImColor( 60,  60,  70,  50);
            editorStyle.Colors[ed::StyleColor_NodeBg]       = ImColor( 32,  32,  32, 228);
            editorStyle.Colors[ed::StyleColor_NodeBorder]   = ImColor(255, 255, 255,  96);
            editorStyle.Colors[ed::StyleColor_SelNodeBorder]= ImColor(255, 176,  50, 255);
            editorStyle.Colors[ed::StyleColor_HovNodeBorder]= ImColor( 50, 176, 255, 255);
            editorStyle.Colors[ed::StyleColor_Flow]         = ImColor( 64, 128,  64, 255);
            editorStyle.Colors[ed::StyleColor_FlowDMarker]  = ImColor(255, 128,  10, 255);
            editorStyle.Colors[ed::StyleColor_FlowMarker]   = ImColor(128, 255, 128, 255);
        }
        break;
    case BluePrintStyle::BP_Style_Light:
        {
            ImGui::StyleColorsLight();
            if (m_Document) m_Document->m_Blueprint.SetStyleLight(true);
            m_FileDialog.SetDarkStyle();
            m_StyleColors[BluePrintStyleColor_GroupBg]              = ImColor(128, 128, 255, 128);
            m_StyleColors[BluePrintStyleColor_TitleBg]              = ImColor(128, 128, 255,  64);
            m_StyleColors[BluePrintStyleColor_ToolButtonActive]     = ImColor( 96,  96, 255, 192);
            m_StyleColors[BluePrintStyleColor_ToolButtonHovered]    = ImColor( 96,  96, 255, 128);
            m_StyleColors[BluePrintStyleColor_DebugCurrentNode]     = ImColor(  0, 255,   0, 128);
            m_StyleColors[BluePrintStyleColor_DebugNextNode]        = ImColor(  0,   0, 255, 128);
            m_StyleColors[BluePrintStyleColor_DebugBreakPointNode]  = ImColor(255,   0,   0, 128);
            m_StyleColors[BluePrintStyleColor_PinVoid]      = ImColor(   0,   0,   0, 255);
            m_StyleColors[BluePrintStyleColor_PinAny]       = ImColor(   0,   0,   0, 200);
            m_StyleColors[BluePrintStyleColor_PinFlow]      = ImColor(   0,   0,   0, 200);
            m_StyleColors[BluePrintStyleColor_PinBool]      = ImColor(  48, 48,  220, 255);
            m_StyleColors[BluePrintStyleColor_PinInt32]     = ImColor(  68, 201, 156, 255);
            m_StyleColors[BluePrintStyleColor_PinInt64]     = ImColor( 100,  34,  78, 255);
            m_StyleColors[BluePrintStyleColor_PinFloat]     = ImColor(  74, 113,  37, 255);
            m_StyleColors[BluePrintStyleColor_PinDouble]    = ImColor(  36,  56,  17, 255);
            m_StyleColors[BluePrintStyleColor_PinString]    = ImColor( 124,  21, 153, 255);
            m_StyleColors[BluePrintStyleColor_PinPoint]     = ImColor( 220, 110,  10, 255);
            m_StyleColors[BluePrintStyleColor_PinVector]    = ImColor(  72, 110, 220, 255);
            m_StyleColors[BluePrintStyleColor_PinMat]       = ImColor( 220,  10,  10, 255);
            m_StyleColors[BluePrintStyleColor_PinCustom]    = ImColor( 208,  64,  64, 255);
            auto& editorStyle = ed::GetStyle();
            editorStyle.Colors[ed::StyleColor_Bg]           = ImColor( 220, 220, 252,  72);
            editorStyle.Colors[ed::StyleColor_NodeBg]       = ImColor( 200, 200, 230, 228);
            editorStyle.Colors[ed::StyleColor_NodeBorder]   = ImColor( 128, 128, 255,  96);
            editorStyle.Colors[ed::StyleColor_SelNodeBorder]= ImColor(  20,  20, 255, 255);
            editorStyle.Colors[ed::StyleColor_HovNodeBorder]= ImColor(  50, 176, 255, 255);
            editorStyle.Colors[ed::StyleColor_Flow]         = ImColor(  64, 128,  64, 255);
            editorStyle.Colors[ed::StyleColor_FlowDMarker]  = ImColor( 255, 128,  10, 255);
            editorStyle.Colors[ed::StyleColor_FlowMarker]   = ImColor( 128, 255, 128, 255);
        }
        break;
    case BluePrintStyle::BP_Style_Mono:
        {
            ImGui::StyleColorsLight();
            m_FileDialog.SetLightStyle();
            if (m_Document) m_Document->m_Blueprint.SetStyleLight(true);
            m_StyleColors[BluePrintStyleColor_GroupBg]              = ImColor(196, 196, 196, 196);
            m_StyleColors[BluePrintStyleColor_TitleBg]              = ImColor(128, 128, 128,  64);
            m_StyleColors[BluePrintStyleColor_ToolButtonActive]     = ImColor( 96,  96, 96, 192);
            m_StyleColors[BluePrintStyleColor_ToolButtonHovered]    = ImColor( 96,  96, 96, 128);
            m_StyleColors[BluePrintStyleColor_PinVoid]      = ImColor(   0,   0,   0, 255);
            m_StyleColors[BluePrintStyleColor_PinAny]       = ImColor(   0,   0,   0, 200);
            m_StyleColors[BluePrintStyleColor_PinFlow]      = ImColor(   0,   0,   0, 200);
            m_StyleColors[BluePrintStyleColor_PinBool]      = ImColor(  48,  48,   48, 255);
            m_StyleColors[BluePrintStyleColor_PinInt32]     = ImColor( 128, 128, 128, 255);
            m_StyleColors[BluePrintStyleColor_PinInt64]     = ImColor( 144, 144, 144, 255);
            m_StyleColors[BluePrintStyleColor_PinFloat]     = ImColor(  74,  74,  74, 255);
            m_StyleColors[BluePrintStyleColor_PinDouble]    = ImColor(  36,  36,  36, 255);
            m_StyleColors[BluePrintStyleColor_PinString]    = ImColor(  48,  48,  48, 255);
            m_StyleColors[BluePrintStyleColor_PinPoint]     = ImColor(  64,  64,  64, 255);
            m_StyleColors[BluePrintStyleColor_PinVector]    = ImColor(  32,  32,  32, 255);
            m_StyleColors[BluePrintStyleColor_PinMat]       = ImColor(110, 110, 110, 255);
            m_StyleColors[BluePrintStyleColor_PinCustom]    = ImColor(  20,  20,  20, 255);
            m_StyleColors[BluePrintStyleColor_DebugCurrentNode]     = ImColor(   0,   0,   0, 128);
            m_StyleColors[BluePrintStyleColor_DebugNextNode]        = ImColor(  64,  64,  64, 128);
            m_StyleColors[BluePrintStyleColor_DebugBreakPointNode]  = ImColor(   0,   0,   0, 128);

            auto& editorStyle = ed::GetStyle();
            editorStyle.Colors[ed::StyleColor_Bg]           = ImColor( 220, 220, 220,  72);
            editorStyle.Colors[ed::StyleColor_NodeBg]       = ImColor( 200, 200, 200, 228);
            editorStyle.Colors[ed::StyleColor_NodeBorder]   = ImColor( 128, 128, 128,  96);
            editorStyle.Colors[ed::StyleColor_SelNodeBorder]= ImColor(  20,  20,  20, 255);
            editorStyle.Colors[ed::StyleColor_HovNodeBorder]= ImColor(  72,  72,  72, 255);
            editorStyle.Colors[ed::StyleColor_Flow]         = ImColor(  64,  64,  64, 255);
            editorStyle.Colors[ed::StyleColor_FlowDMarker]  = ImColor(  32,  32,  32, 255);
            editorStyle.Colors[ed::StyleColor_FlowMarker]   = ImColor(  10,  10,  10, 128);
        }
        break;
    default:
        break;
    }
    m_Style = style;
}

void BluePrintUI::SetCallbacks(BluePrintCallbackFunctions callbacks, void * handle)
{
    m_CallBacks = callbacks;
    m_UserHandle = handle;
}

bool BluePrintUI::Frame(bool child_window, bool show_node, bool bp_enabled, uint32_t flag)
{
    bool done = false;
    if (!m_Editor || !m_Document || ReadyToQuit)
        return true;
    auto& io = ImGui::GetIO();
    bool multiviewport = io.ConfigFlags & ImGuiConfigFlags_ViewportsEnable;
    const ImGuiViewport* viewport = ImGui::GetMainViewport();
    if (!child_window)
    {
        m_isChildWindow = false;
        if (m_DebugOverlay) m_DebugOverlay->Enable(true);
        ImVec2 Canvas_size;
        ImGuiWindowFlags flags = ImGuiWindowFlags_None;
        ImGuiCond cond = ImGuiCond_Once;
        if (io.ConfigFlags & ImGuiConfigFlags_ViewportsEnable)
        {
            io.ConfigViewportsNoDecoration = false;
            flags = ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoMove |
                        ImGuiWindowFlags_NoScrollbar | ImGuiWindowFlags_NoScrollWithMouse | 
                        ImGuiWindowFlags_NoSavedSettings | ImGuiWindowFlags_NoBringToFrontOnFocus | ImGuiWindowFlags_NoDocking;
            Canvas_size = viewport->WorkSize;
            ImGui::SetNextWindowPos(viewport->WorkPos);
            ImGui::SetNextWindowSize(viewport->WorkSize);
            ImGui::SetNextWindowViewport(viewport->ID);
        }
        else
        {
            flags = ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoMove |
                            ImGuiWindowFlags_NoScrollbar | ImGuiWindowFlags_NoScrollWithMouse | 
                            ImGuiWindowFlags_NoSavedSettings | ImGuiWindowFlags_NoBringToFrontOnFocus;
            Canvas_size = io.DisplaySize;
            cond = ImGuiCond_None;
            ImGui::SetNextWindowPos(ImVec2(0, 0));
            ImGui::SetNextWindowSize(io.DisplaySize, cond);
        }
        
        ImGui::Begin("Content", nullptr, flags);
            ImVec2 debug_min = ImGui::GetItemRectMin();
            ImVec2 debug_max = Canvas_size;
            if (io.ConfigFlags & ImGuiConfigFlags_ViewportsEnable)
            {
                debug_min = ImGui::GetWindowPos();
                debug_max = debug_min + ImGui::GetWindowSize();
            }
            ed::SetCurrentEditor(m_Editor);
            UpdateActions();
            ShowToolbar();
            if (m_isShowThumbnails || m_ThumbnailShowCount > 0) Thumbnails(2.f);
            ed::Begin("###main_editor");
                if (show_node)
                    DrawNodes();
                else
                    CommitLinksToEditor();
                HandleCreateAction();
                HandleDestroyAction();
                HandleContextMenuAction();
                ShowDialogs();
                DrawInfoTooltip();
            ed::End();
            FileDialogs();
            ed::SetCurrentEditor(nullptr); // Don't Stop ed?

        ImGui::End();
        io.ConfigViewportsNoDecoration = true;
    }
    else
    {
        m_isChildWindow = true;
        if (m_DebugOverlay) m_DebugOverlay->Enable(false);
        ed::SetCurrentEditor(m_Editor);
        UpdateActions();
        ShowShortToolbar(flag & BluePrintFlag_Vertical);
        if (m_isShowThumbnails || m_ThumbnailShowCount > 0)
        {
            ImVec2 window_pos = ImGui::GetWindowPos();
            ImVec2 window_size = ImGui::GetWindowSize();
            Thumbnails(2.f, window_size, window_pos + window_size - window_size * m_ThumbnailScale);
        }
        ed::Begin("###main_editor");
        if (bp_enabled)
        {
            if (show_node)
                DrawNodes();
            else
                CommitLinksToEditor();
            HandleCreateAction(flag);
            HandleDestroyAction();
            HandleContextMenuAction(flag);
            ShowDialogs();
            DrawInfoTooltip(); // for debug
        }
        ed::End();
        FileDialogs();
        ed::SetCurrentEditor(nullptr);
    }
    return done;
}

void BluePrintUI::CreateNewDocument()
{
    auto blueprint = &m_Document->m_Blueprint;
    auto entryPointNode = blueprint->CreateNode<BluePrint::SystemEntryPointNode>();
                            ed::SetNodePosition(entryPointNode->m_ID, ImVec2(32, 32));

    auto exitPointNode = blueprint->CreateNode<BluePrint::SystemExitPointNode>();
                            ed::SetNodePosition(exitPointNode->m_ID, ImVec2(128, 128));
    entryPointNode->m_Exit.LinkTo(exitPointNode->m_Enter);
    CommitLinksToEditor();
    blueprint->SetOpen(true);
}

void BluePrintUI::CreateNewFilterDocument()
{
    auto blueprint = &m_Document->m_Blueprint;
    auto entryPointNode = blueprint->CreateNode<BluePrint::FilterEntryPointNode>();
                            ed::SetNodePosition(entryPointNode->m_ID, ImVec2(32, 32));

    auto view_size = ed::GetViewSize();
    if (view_size.x == 0 || view_size.y == 0)
        view_size = ImVec2(400, 200);
    auto exitPointNode = blueprint->CreateNode<BluePrint::MatExitPointNode>();
                            ed::SetNodePosition(exitPointNode->m_ID, view_size - ImVec2(32 + 64, 32));
    entryPointNode->m_Exit.LinkTo(exitPointNode->m_Enter);
    exitPointNode->m_MatIn.LinkTo(entryPointNode->m_MatOut);
    CommitLinksToEditor();
    blueprint->SetOpen(true);
}

void BluePrintUI::CreateNewFusionDocument()
{
    auto blueprint = &m_Document->m_Blueprint;
    auto entryPointNode = blueprint->CreateNode<BluePrint::FusionEntryPointNode>();
                            ed::SetNodePosition(entryPointNode->m_ID, ImVec2(32, 32));

    auto view_size = ed::GetViewSize();
    if (view_size.x == 0 || view_size.y == 0)
        view_size = ImVec2(400, 200);

    auto exitPointNode = blueprint->CreateNode<BluePrint::MatExitPointNode>();
                            ed::SetNodePosition(exitPointNode->m_ID, view_size - ImVec2(32 + 64, 32));

    entryPointNode->m_Exit.LinkTo(exitPointNode->m_Enter);
    exitPointNode->m_MatIn.LinkTo(entryPointNode->m_MatOutFirst);
    CommitLinksToEditor();
    blueprint->SetOpen(true);
}

void BluePrintUI::InstallDocumentCallbacks()
{
    m_Config.UserPointer = this;
    m_Config.BeginSaveSession = [](void* userPointer)
    {
        auto self = reinterpret_cast<BluePrintUI*>(userPointer);
        if (self && self->m_Document)
            self->m_Document->OnSaveBegin();
    };
    m_Config.EndSaveSession = [](void* userPointer)
    {
        auto self = reinterpret_cast<BluePrintUI*>(userPointer);
        if (self && self->m_Document)
            self->m_Document->OnSaveEnd();
    };
    m_Config.SaveSettingsJson = [](const imgui_json::value& state, ed::SaveReasonFlags reason, void* userPointer) -> bool
    {
        auto self = reinterpret_cast<BluePrintUI*>(userPointer);
        if (self && self->m_Document)
            return self->m_Document->OnSaveState(state, reason);
        else
            return false;
    };
    m_Config.LoadSettingsJson = [](void* userPointer) -> imgui_json::value
    {
        auto self = reinterpret_cast<BluePrintUI*>(userPointer);
        if (self && self->m_Document)
            return self->m_Document->OnLoadState();
        else
            return {};
    };
    m_Config.SaveNodeSettingsJson = [](ed::NodeId nodeId, const imgui_json::value& value, ed::SaveReasonFlags reason, void* userPointer) -> bool
    {
        auto self = reinterpret_cast<BluePrintUI*>(userPointer);
        if (self && self->m_Document)
            return self->m_Document->OnSaveNodeState(static_cast<ID_TYPE>(nodeId.Get()), value, reason);
        else
            return false;
    };
    m_Config.LoadNodeSettingsJson = [](ed::NodeId nodeId, void* userPointer) -> imgui_json::value
    {
        auto self = reinterpret_cast<BluePrintUI*>(userPointer);
        if (self && self->m_Document)
            return self->m_Document->OnLoadNodeState(static_cast<ID_TYPE>(nodeId.Get()));
        else
            return {};
    };

    struct TransactionWrapper final: ed::ITransaction
    {
        static const char* ActionToString(ed::TransactionAction action)
        {
            switch (action)
            {
                case ed::TransactionAction::Unknown:    return "Unknown";
                case ed::TransactionAction::Navigation: return "Navigation";
                case ed::TransactionAction::DragStart:  return "DragStart";
                case ed::TransactionAction::DragEnd:    return "DragEnd";
                case ed::TransactionAction::Resize:     return "Resize";
                default : return "";
            }
            return "";
        }
        TransactionWrapper(shared_ptr<BluePrint::Document::UndoTransaction> transaction)
            : m_Transaction(std::move(transaction))
        {
        }
        void AddAction(ed::TransactionAction action, const char* name) override
        {
            if (action == ed::TransactionAction::Navigation)
            {
                auto self = reinterpret_cast<BluePrintUI*>(m_Transaction->GetDocument()->m_UserData);
                if (self) self->m_ThumbnailShowCount = THUMBNAIL_COUNT;
            }
        }
        void Commit() override
        {
            ImGuiTextBuffer name;
            if (m_ActionCount == m_DragActionCount && m_DragActionCount > 1)
                name.appendf("Drag %d nodes", static_cast<int>(m_DragActionCount));
            m_Transaction->Commit(name.c_str());
        }
        void Discard() override
        {
            m_Transaction->Discard();
        }
        void AddAction(ed::TransactionAction action, ed::NodeId nodeId, const char* name) override
        {
            auto& blueprint = m_Transaction->GetDocument()->GetBlueprint();
            auto  node = const_cast<BP&>(blueprint).FindNode(static_cast<ID_TYPE>(nodeId.Get()));
            if (!node)
                return;
            ++m_ActionCount;
            m_NodeIds.push_back(nodeId);
            if (action == ed::TransactionAction::DragStart)
            {
                ++m_DragActionCount;
                node->OnDragStart(blueprint.GetContext());
                m_Transaction->AddAction("Drag Start %" PRI_node, FMT_node(node));
            }
            else if (action == ed::TransactionAction::DragEnd)
            {
                ++m_DragActionCount;
                node->OnDragEnd(blueprint.GetContext());
                m_Transaction->AddAction("Drag End %" PRI_node, FMT_node(node));
            }
            else if (action == ed::TransactionAction::Resize)
            {
                node->OnResize(blueprint.GetContext());
                m_Transaction->AddAction("Resize %" PRI_node, FMT_node(node));
            }
            else if (action == ed::TransactionAction::Select)
            {
                node->OnSelect(blueprint.GetContext());
                m_Transaction->AddAction("Select %" PRI_node, FMT_node(node));
            }
            else if (action == ed::TransactionAction::Deselect)
            {
                node->OnDeselect(blueprint.GetContext());
                m_Transaction->AddAction("Deselect %" PRI_node, FMT_node(node));
            }
            else
                m_Transaction->AddAction("%s", name);
        }
        void AddAction(ed::TransactionAction action, ed::LinkId linkId, const char* name) override
        {
            auto& blueprint = m_Transaction->GetDocument()->GetBlueprint();
            auto  link = const_cast<BP&>(blueprint).FindPin(static_cast<ID_TYPE>(linkId.Get()));
            if (!link)
                return;
            ++m_ActionCount;
            m_Transaction->AddAction("%s Link %" PRIX32, name, link->m_ID);
        }
        shared_ptr<BluePrint::Document::UndoTransaction> m_Transaction;
        size_t m_ActionCount = 0;
        size_t m_DragActionCount = 0;
        vector<ed::NodeId> m_NodeIds;
    };
    m_Config.TransactionInterface.Constructor = [](const char* name, void* userPointer) -> ed::ITransaction*
    {
        auto self = reinterpret_cast<BluePrintUI*>(userPointer);
        if (!self || !self->m_Document) return nullptr;
        return new TransactionWrapper(self->m_Document->BeginUndoTransaction(name));
    };
    m_Config.TransactionInterface.Destructor = [](ed::ITransaction* transaction, void* userPointer)
    {
        delete transaction;
    };
    m_Config.TransactionInterface.UserPointer = this;
}

float BluePrintUI::DrawNodeToolBar(Node *node, Node **need_clone_node)
{
    if (!m_Document)
        return 0.f;
    auto current_pos = ImGui::GetCursorScreenPos();
    bool isThreadExecuting = m_Document->m_Blueprint.IsExecuting();
    ImGui::PushStyleColor(ImGuiCol_Button, m_StyleColors[BluePrintStyleColor_ToolButton]);
    ImGui::PushStyleColor(ImGuiCol_ButtonHovered, m_StyleColors[BluePrintStyleColor_ToolButtonHovered]);
    ImGui::PushStyleColor(ImGuiCol_ButtonActive, m_StyleColors[BluePrintStyleColor_ToolButtonActive]);
    ImGui::PushStyleVar(ImGuiStyleVar_ItemSpacing, ImVec2(0,0));
    ImGui::PushStyleVar(ImGuiStyleVar_ItemInnerSpacing, ImVec2(0,0));
    ImGui::PushStyleVar(ImGuiStyleVar_TexGlyphShadowOffset, ImVec2(2.0, 2.0));

    auto node_size = ed::GetNodeSize(node->m_ID);
    float icon_offset = 16 + 2; // base offset + resize speed
    const float icon_gap = 18;
    if (node->Skippable())
    {
        icon_offset += icon_gap;
        ImGui::SetCursorScreenPos(current_pos + ImVec2(node_size.x - icon_offset, 8));
        if (ImGui::Button((std::string((node->m_Enabled ? ICON_NODE_ENABLE : ICON_NODE_DISABLE)) + "##" + std::to_string(node->m_ID)).c_str())) 
        {
            node->m_Enabled = !node->m_Enabled;
            if (node->m_Enabled) LOGI("[HandleNodeToolBar] Enable for %" PRI_node, FMT_node(node));
            else                 LOGI("[HandleNodeToolBar] Disable for %" PRI_node, FMT_node(node));
            ed::SetNodeChanged(node->m_ID);
            if (m_CallBacks.BluePrintOnChanged)
            {
                m_CallBacks.BluePrintOnChanged(BP_CB_PARAM_CHANGED, m_Document->m_Name, m_UserHandle);
            }
        }
        if (ImGui::IsItemHovered()) node->m_IconHovered = 4;
    }
    ImGui::BeginDisabled(isThreadExecuting);
    if (node->GetStyle() == NodeStyle::Group)
    {
        icon_offset += icon_gap;
        ImGui::SetCursorScreenPos(current_pos + ImVec2(node_size.x - icon_offset, 8));
        if (ImGui::Button((titlebar_icons[3] + "##" + std::to_string(node->m_ID)).c_str())) 
        {
            ed::Suspend();
            LOGI("[HandleNodeToolBar] Open NodeSavingDialog for %" PRI_node, FMT_node(node));
            File_Export(node);
            ed::Resume();
        }
        if (ImGui::IsItemHovered()) node->m_IconHovered = 3;
    }
    if (node->HasSetting())
    {
        icon_offset += icon_gap;
        ImGui::SetCursorScreenPos(current_pos + ImVec2(node_size.x - icon_offset, 8));
        if (ImGui::Button((titlebar_icons[2] + "##" + std::to_string(node->m_ID)).c_str())) 
        {
            ed::Suspend();
            LOGI("[HandleNodeToolBar] Open NodeSettingDialog for %" PRI_node, FMT_node(node));
            m_NodeSettingDialog.Open(node);
            ed::Resume();
        }
        if (ImGui::IsItemHovered()) node->m_IconHovered = 2;
    }

    icon_offset += icon_gap;
    ImGui::SetCursorScreenPos(current_pos + ImVec2(node_size.x - icon_offset, 8));
    if (ImGui::Button((titlebar_icons[1] + "##" + std::to_string(node->m_ID)).c_str())) 
    {
        ed::Suspend();
        LOGI("[HandleNodeToolBar] Open NodeDeleteDialog for %" PRI_node, FMT_node(node));
        m_NodeDeleteDialog.Open(node);
        ed::Resume();
    }
    if (ImGui::IsItemHovered()) node->m_IconHovered = 1;

    icon_offset += icon_gap;
    ImGui::SetCursorScreenPos(current_pos + ImVec2(node_size.x - icon_offset, 8));
    if (ImGui::Button((titlebar_icons[0] + "##" + std::to_string(node->m_ID)).c_str())) 
    {
        *need_clone_node = node;
    }
    if (ImGui::IsItemHovered()) node->m_IconHovered = 0;

    ImGui::EndDisabled();
    ImGui::PopStyleVar(3);
    ImGui::PopStyleColor(3);
    return icon_offset;
}

bool BluePrintUI::CheckNodeStyle(const Node* node, NodeStyle style)
{
    bool checked = false;
    DummyNode * dummy = nullptr;
    auto isDummy = node->GetStyle() == NodeStyle::Dummy;
    if (isDummy)
        dummy = (DummyNode *)node;
    checked = node->GetStyle() == style || (dummy ? dummy->m_style == style : false);
    return checked;
}

void BluePrintUI::CommitLinksToEditor()
{
    auto pins = m_Document->m_Blueprint.GetPins();
    for (auto pin : pins)
    {
        if (!pin->m_Link)
        {
            if (!(pin->m_Flags & PIN_FLAG_LINKED)) pin->m_LinkFrom.clear();
            continue;
        }

        auto link = pin->GetLink(&m_Document->m_Blueprint);
        if (!link)
        {
            pin->m_Link = 0;
            pin->m_LinkPin = nullptr;
            continue;
        }
        else
        {
            pin->m_LinkPin = link;
        }

        if (std::find(pins.begin(), pins.end(), link) == pins.end())
        {
            pin->m_Link = 0;
            pin->m_LinkPin = nullptr;
            continue;
        }
        
        // To keep things simple, link id is same as pin id.
        // check link is between bridge and shadow
        //bool inner_link = pin->IsMappedPin() && link->IsMappedPin() && pin->m_MappedPin && pin->m_MappedPin == link->m_MappedPin;
        //ed::Link(pin->m_ID, pin->m_ID, pin->m_Link, (inner_link ? ImVec4(0, 0, 0,  0) : PinTypeToColor(this, pin->GetValueType())), 1.5); // Maybe add to setting
        ed::Link(pin->m_ID, pin->m_ID, pin->m_Link, PinTypeToColor(this, pin->GetValueType()), 3.0); // Maybe add to setting
        pin->m_Flags |= PIN_FLAG_LINKED;
        link->m_Flags |= PIN_FLAG_LINKED;
        if (std::find(link->m_LinkFrom.begin(), link->m_LinkFrom.end(), pin->m_ID) == link->m_LinkFrom.end())
        {
            link->m_LinkFrom.push_back(pin->m_ID);
        }
    }
}

void BluePrintUI::DrawNodes()
{
    if (!m_Document)
        return;
    const auto iconSize = ImVec2(ImGui::GetTextLineHeight(), ImGui::GetTextLineHeight());
    if (m_DebugOverlay) m_DebugOverlay->Begin();
    Node* need_clone_node = nullptr;
    auto show_pin_name = [](std::string name)
    {
        auto pos = name.find_first_of("##");
        if (pos == std::string::npos)
            ImGui::TextUnformatted(name.data(), name.data() + name.size());
        else
        {
            auto sub_label = name.substr(0, pos);
            ImGui::TextUnformatted(sub_label.data(), sub_label.data() + sub_label.size());
        }
    };
    // Commit all nodes to editor
    // Handling Comment/Group Node
    for (auto& node : m_Document->m_Blueprint.GetNodes())
    {
        auto isDummy = node->GetStyle() == NodeStyle::Dummy;
        auto isGroup = CheckNodeStyle(node, NodeStyle::Group);
        auto isGrouped = node->m_GroupID != 0;
        if (!CheckNodeStyle(node, NodeStyle::Comment) && !CheckNodeStyle(node, NodeStyle::Group))
            continue;
        const float commentAlpha = 0.75f;
        node->m_IconHovered = -1;
        ImGui::PushStyleVar(ImGuiStyleVar_Alpha, commentAlpha);
        //ed::PushStyleColor(ed::StyleColor_NodeBg, m_StyleColors[BluePrintStyleColor_GroupBg]);
        if (isDummy)
        {
            ed::PushStyleColor(ed::StyleColor_NodeBorder, m_StyleColors[BluePrintStyleColor_DummyBorder]);
        }
        else
        {
            ed::PushStyleColor(ed::StyleColor_NodeBorder, m_StyleColors[BluePrintStyleColor_Border]);
        }
        ed::BeginNode(node->m_ID);
        if (node->m_NeedUpdate)
        {
            ed::SetNodeChanged(node->m_ID);
            node->m_NeedUpdate = false;
        }
        // Comment/Group node layout:
        //
        // [ Comment ]                         |     [ Group ]                              |
        // +-----------------------------------+     +--------------------------------------+
        // | Title                  iC iD iS   |     | Title                    is iC iD iS |
        // | +-----------[ Dummy ]-----------+ |     | +-----------[ Dummy ]--------------+ |
        // |                                   |     || i Pin |                    | Pin o ||
        // |                                   |     || i Pin |                    | Pin o ||
        // |            [ Content ]            |     |    .        [ Content ]         .    |
        // |                                   |     |    .                            .    |
        // |                                   |     || i Pin |                    | Pin o ||
        // +-----------------------------------+     +--------------------------------------+
        // PS: iS = Setting Icon, iC = Clone Icon, iD = Delete Icon, is = Save Icon
        ImGui::BeginVertical("content");
        // Show title if node has one.
        auto nodeName = !isDummy ? node->GetName() : ((DummyNode *)node)->m_name + "*load fail*";
        float title_height = 0;
        float title_width = 0;
        if (!nodeName.empty())
        {
            const float titleTextWidth = ImGui::CalcTextSize(nodeName.c_str()).x;
            const float titleTextHeight = ImGui::CalcTextSize(nodeName.c_str()).y;
            const float textSizeButton = ImGui::CalcTextSize(titlebar_icons[0].c_str()).x;
            const float dummyWidth = titleTextWidth + textSizeButton * 5 + 10;
            ImGui::PushStyleVar(ImGuiStyleVar_TexGlyphShadowOffset, ImVec2(2.0, 2.0));
            ImGui::PushStyleVar(ImGuiStyleVar_TexGlyphOutlineWidth, 1.0f);
            ImGui::PushStyleColor(ImGuiCol_TexGlyphOutline, ImVec4(0.5, 0.5, 1.0, 1.0));
            ImGui::Dummy(ImVec2(dummyWidth, 0));
            ImGui::BeginHorizontal("horizontal");
            ImFont* font = HeaderFont();
            if (font) ImGui::PushFont(font);
            ImGui::TextUnformatted(nodeName.data());
            if (font) ImGui::PopFont();
            ImGui::EndHorizontal();
            ImGui::Dummy(ImVec2(dummyWidth, 8));
            title_height = titleTextHeight + 10;
            title_width = dummyWidth;
            ImGui::PopStyleVar(2);
            ImGui::PopStyleColor(1);
        }
        ImGui::EndVertical();
        auto nodeStart = ed::GetNodePosition(node->m_ID);
        ImGui::SetCursorScreenPos(nodeStart);
        if (!isDummy) title_width += DrawNodeToolBar(node, &need_clone_node);
        auto inPinPosMin = ed::GetNodePosition(node->m_ID); inPinPosMin.x += 8; inPinPosMin.y += title_height + 16;
        auto groupSize  = ed::GetGroupSize(node->m_ID);
        if (groupSize.x == 0)
            groupSize.x = title_width;
        ed::Group(groupSize);
        auto outPinPosMin = ed::GetNodePosition(node->m_ID); outPinPosMin.x += groupSize.x - 16; outPinPosMin.y += title_height + 16;

        if (isGroup)
        {
            node->Update();
            auto drawList = ImGui::GetWindowDrawList();
            auto num_inpin = node->GetInputPins().size();
            if (num_inpin > 0)
            {
                // Input pin layout:
                //
                //     +-[1]---+
                //     |       |
                //    [X] Icon |
                //     |       |
                //     +-------+
                auto inPinPosMax = inPinPosMin + ImVec2(24, num_inpin * (iconSize.y + 4) + 4);
                drawList->AddRectFilled(
                    inPinPosMin,
                    inPinPosMax,
                    ImGui::GetColorU32(m_StyleColors[BluePrintStyleColor_GroupBg]), 8.0f);
                auto PinMin = inPinPosMin + ImVec2(4, 4);
                for (auto& pin : node->GetInputPins())
                {
                    auto PinMax = PinMin + iconSize;
                    // draw shadow pin
                    if (pin->m_Type == PinType::Flow)
                    {
                        auto spin = pin->GetLink(&m_Document->m_Blueprint);
                        if (spin)
                        {
                            ed::BeginPin(spin->m_ID, ed::PinKind::Output);
                            ed::PinPivotAlignment(ImVec2(1.0f, 0.5f));
                            ed::PinRect(PinMin, PinMax);
                            DrawIcon(drawList, PinMin, PinMax,
                                    PinTypeToIconType(spin->GetType()),
                                    false,
                                    ImColor(ImVec4(0, 0, 0, 0)),
                                    ImColor(ImVec4(0, 0, 0, 0)));
                            ed::EndPin();
                        }
                    }
                    else
                    {
                        if (pin->m_LinkFrom.size() == 1)
                        {
                            auto spin = m_Document->m_Blueprint.GetPinFromID(pin->m_LinkFrom[0]);
                            if (spin)
                            {
                                ed::BeginPin(spin->m_ID, ed::PinKind::Output);
                                ed::PinPivotAlignment(ImVec2(1.0f, 0.5f));
                                ed::PinRect(PinMin, PinMax);
                                DrawIcon(drawList, PinMin, PinMax,
                                        PinTypeToIconType(spin->GetType()),
                                        false,
                                        ImColor(ImVec4(0, 0, 0, 0)),
                                        ImColor(ImVec4(0, 0, 0, 0)));
                                ed::EndPin();
                            }
                        }
                    }
                    // draw bridge pin
                    bool link_outside = false;
                    if (pin->m_Type == PinType::Flow)
                        link_outside = pin->m_LinkFrom.size() > 0;
                    else
                        link_outside = pin->m_Link != 0;
                    ed::BeginPin(pin->m_ID, ed::PinKind::Input);
                    ed::PinPivotAlignment(ImVec2(1.0f, 0.5f));
                    ed::PinRect(PinMin, PinMax);
                    DrawIcon(drawList, PinMin, PinMax,
                            PinTypeToIconType(pin->GetType()),
                            link_outside,
                            ImColor(PinTypeToColor(this, pin->GetValueType())),
                            ImColor(ImVec4(0, 0, 0, 0)));
                    ed::EndPin();

                    m_DebugOverlay->DrawInputPin(this, *pin);
                    PinMin += ImVec2(0, iconSize.y + 4);
                    //ImGui::Debug_DrawItemRect();
                }
            }
            // Output pin layout:
            //
            //    +-[1]---+
            //    |       |
            //    | Icon [X]
            //    |       |
            //    +-------+
            auto num_outpin = node->GetOutputPins().size();
            if (num_outpin > 0)
            {
                auto outPinPosMax = outPinPosMin + ImVec2(24, num_outpin * (16 + 4) + 4);
                drawList->AddRectFilled(
                    outPinPosMin,
                    outPinPosMax,
                    ImGui::GetColorU32(m_StyleColors[BluePrintStyleColor_GroupBg]), 8.0f);
                auto PinMin = outPinPosMin + ImVec2(4, 4);
                for (auto& pin : node->GetOutputPins())
                {
                    auto PinMax = PinMin + iconSize;
                    // draw shadow pin
                    if (pin->m_Type == PinType::Flow)
                    {
                        if (pin->m_LinkFrom.size() == 1)
                        {
                            auto spin = m_Document->m_Blueprint.GetPinFromID(pin->m_LinkFrom[0]);
                            if (spin)
                            {
                                ed::BeginPin(spin->m_ID, ed::PinKind::Input);
                                ed::PinPivotAlignment(ImVec2(0.0f, 0.5f));
                                ed::PinRect(PinMin, PinMax);
                                DrawIcon(drawList, PinMin, PinMax,
                                        PinTypeToIconType(spin->GetType()),
                                        false,
                                        ImColor(ImVec4(0, 0, 0, 0)),
                                        ImColor(ImVec4(0, 0, 0, 0)));
                                ed::EndPin();
                            }
                        }
                    }
                    else
                    {
                        auto spin = pin->GetLink(&m_Document->m_Blueprint);
                        if (spin)
                        {
                            ed::BeginPin(spin->m_ID, ed::PinKind::Input);
                            ed::PinPivotAlignment(ImVec2(0.0f, 0.5f));
                            ed::PinRect(PinMin, PinMax);
                            DrawIcon(drawList, PinMin, PinMax,
                                    PinTypeToIconType(spin->GetType()),
                                    false,
                                    ImColor(ImVec4(0, 0, 0, 0)),
                                    ImColor(ImVec4(0, 0, 0, 0)));
                            ed::EndPin();
                        }
                    }
                    // draw bridge pin
                    bool link_outside = false;
                    if (pin->m_Type == PinType::Flow)
                        link_outside = pin->m_Link != 0;
                    else
                        link_outside = pin->m_LinkFrom.size() > 0;
                    ed::BeginPin(pin->m_ID, ed::PinKind::Output);
                    ed::PinPivotAlignment(ImVec2(0.2f, 0.5f));
                    ed::PinRect(PinMin, PinMax);
                    DrawIcon(drawList, PinMin, PinMax,
                            PinTypeToIconType(pin->GetType()),
                            link_outside,
                            ImColor(PinTypeToColor(this, pin->GetValueType())),
                            ImColor(ImVec4(0, 0, 0, 0)));
                    ed::EndPin();
                    if (m_DebugOverlay) m_DebugOverlay->DrawOutputPin(this, *pin);
                    PinMin += ImVec2(0, iconSize.y + 4);
                    //ImGui::Debug_DrawItemRect();
                }
            }
        }
        ed::EndNode();
#if DEBUG_NODE_DRAWING
        ImGui::Debug_DrawItemRect();
#endif
        ed::PopStyleColor();
        ImGui::PopStyleVar();

        // Draw Title zoom out
        if (ed::BeginGroupHint(node->m_ID))
        {
            auto bgAlpha = static_cast<int>(ImGui::GetStyle().Alpha * 255);
            auto min = ed::GetGroupMin();
            ImGui::SetCursorScreenPos(min - ImVec2(-8, ImGui::GetTextLineHeightWithSpacing() + 4));
            ImGui::BeginGroup();
            ImFont* font = HeaderFont();
            if (font) ImGui::PushFont(font);
            ImGui::TextUnformatted(nodeName.data());
            if (font) ImGui::PopFont();
            ImGui::EndGroup();
            auto drawList = ed::GetHintBackgroundDrawList();
            auto hintBounds      = ed::Detail::ImGui_GetItemRect();
            auto hintFrameBounds = ed::Detail::ImRect_Expanded(hintBounds, 8, 4);
            drawList->AddRectFilled(
                hintFrameBounds.GetTL(),
                hintFrameBounds.GetBR(),
                IM_COL32(255, isDummy ? 0 : 255, isDummy ? 0 : 255, 64 * bgAlpha / 255), 4.0f);
            drawList->AddRect(
                hintFrameBounds.GetTL(),
                hintFrameBounds.GetBR(),
                IM_COL32(255, isDummy ? 0 : 255, isDummy ? 0 : 255, 128 * bgAlpha / 255), 4.0f);
        }
        ed::EndGroupHint();

        if (m_DebugOverlay) m_DebugOverlay->DrawNode(this, *node);
    }

    // Handling Default and SimpleNode
    for (auto& node : m_Document->m_Blueprint.GetNodes())
    {
        auto isDummy = node->GetStyle() == NodeStyle::Dummy;
        auto isGrouped = node->m_GroupID != 0;
        if (!CheckNodeStyle(node, NodeStyle::Default) && !CheckNodeStyle(node, NodeStyle::Simple))
            continue;
        node->m_IconHovered = -1;
        if (isDummy)
        {
            ed::PushStyleColor(ed::StyleColor_NodeBorder,    ImColor(255, 32,  32, 200));
        }
#if DEBUG_GROUP_NODE
        else if (isGrouped)
        {
            ed::PushStyleColor(ed::StyleColor_NodeBorder,    ImColor(32, 255,  32, 200));
        }
#endif
        if (node->m_NoBackGround)
            ed::PushStyleColor(ed::StyleColor_NodeBg, ImVec4(0.f, 0.f, 0.f, 0.f));
        ed::BeginNode(node->m_ID);
        if (node->m_NeedUpdate)
        {
            ed::SetNodeChanged(node->m_ID);
            node->m_NeedUpdate = false;
        }
        // Default node layout:                         Simple node layout:
        //
        // +-----------------------------------+         +-----------------------------------+
        // | Title               iC  iD  iS    |         | | i Pin |               | Pin o | |
        // | +-----------[ Dummy ]-----------+ |         | | i Pin |               | Pin o | |
        // | +---------------+   +-----------+ |         | |   .   |               | Pin o | |
        // | | i Pin         |   |   Out B o | |         | |   .   |    Title      |   .   | |
        // | | i Pin <Value> |   |   Out A o | |         | |   .   |               |   .   | |
        // | | i Pin         |   |           | |         | | i Pin |               |   .   | |
        // | +---------------+   +-----------+ |         | | i Pin |               | Pin o | |
        // +-----------------------------------+         +-----------------------------------+
        // PS: iS = Setting Icon, iC = Clone Icon, iD= Delete Icon
        // Show title if node has one.
        float dummy_width = 40;
        auto nodeName = !isDummy ? node->GetName() : 
                        !CheckNodeStyle(node, NodeStyle::Simple) ? ((DummyNode *)node)->m_name + "*load fail*" : "*err*";
        if (!nodeName.empty() && !CheckNodeStyle(node, NodeStyle::Simple))
        {
            auto headerBackgroundRenderer = ImGui::ItemBackgroundRenderer([node, this](ImDrawList* drawList)
            {
                auto isDummy = node->GetStyle() == NodeStyle::Dummy;
                auto border   = ed::GetStyle().NodeBorderWidth;
                auto rounding = ed::GetStyle().NodeRounding;
                auto nodeStart = ed::GetNodePosition(node->m_ID);
                auto nodeSize  = ed::GetNodeSize(node->m_ID);
                auto itemMin = ImGui::GetItemRectMin();
                auto itemMax = ImGui::GetItemRectMax();
                itemMin   = nodeStart;
                itemMin.x = itemMin.x + border - 0.5f;
                itemMin.y = itemMin.y + border - 0.5f;
                itemMax.x = nodeStart.x + nodeSize.x - border + 0.5f;
                itemMax.y = itemMax.y + ImGui::GetStyle().ItemSpacing.y + 0.5f;
                drawList->AddRectFilled(itemMin, itemMax, ImColor(isDummy ? m_StyleColors[BluePrintStyleColor_TitleBgDummy] : m_StyleColors[BluePrintStyleColor_TitleBg]), rounding, ImDrawCornerFlags_Top);
                auto size = ImVec2(8.0f, 8.0f);
                auto pos = itemMin + ImVec2(6, (itemMax.y - itemMin.y) / 2 - size.y / 2);
                if (ImGui::BulletToggleButton("##set_break_point", &node->m_BreakPoint, pos, size))
                {
                    ed::SetNodeChanged(node->m_ID);
                }
                //ImGui::Debug_DrawItemRect();
            });
            ImGui::PushStyleVar(ImGuiStyleVar_TexGlyphShadowOffset, ImVec2(2.0, 2.0));
            ImGui::PushStyleVar(ImGuiStyleVar_TexGlyphOutlineWidth, 1.0f);
            ImGui::PushStyleColor(ImGuiCol_TexGlyphOutline, ImVec4(0.5, 0.5, 1.0, 1.0));
            ImGui::Dummy(ImVec2(0.1f, 0.f)); ImGui::SameLine(0);
            ImFont* font = HeaderFont();
            if (font) ImGui::PushFont(font);
            ImGui::TextUnformatted(nodeName.data(), nodeName.data() + nodeName.size());
            if (font) ImGui::PopFont();
            ImGui::PopStyleColor(1);
            ImGui::PopStyleVar(2);
            const float titleTextSize = ImGui::CalcTextSize(nodeName.c_str()).x;
            if (!isDummy)
            {
                dummy_width = titleTextSize + 18 * 6;
            }
            else
            {
                dummy_width = titleTextSize;
            }
        }

        ImGui::Dummy(ImVec2(dummy_width, 0.0f)); // For minimum node width

        ImGui::Grid layout;
        layout.Begin(node->m_ID, CheckNodeStyle(node, NodeStyle::Simple) || (!m_isChildWindow && node->CustomLayout()) ? 3 : 2, dummy_width + 36);
        layout.SetColumnAlignment(0.0f);
        // Draw column with input pins.
        for (auto& pin : node->GetInputPins())
        {
            // Add a bit of spacing to separate pins and make value not cramped
            ImGui::Spacing();
            // Input pin layout:
            //
            //     +-[1]---+-[2]------+-[3]----------+
            //     |       |          |              |
            //    [X] Icon | Pin Name | Value/Editor |
            //     |       |          |              |
            //     +-------+----------+--------------+
            ed::BeginPin(pin->m_ID, ed::PinKind::Input);
            // [X] - Tell editor to put pivot point in the middle of
            //       the left side of the pin. This is the point
            //       where link will be hooked to.
            //
            //       By default pivot is in pin center point which
            //       does not look good for blueprint nodes.
            ed::PinPivotAlignment(ImVec2(0.0f, 0.5f));
            // [1] - Icon
            Icon(iconSize,
                PinTypeToIconType(pin->GetType()),
                m_Document->m_Blueprint.HasPinAnyLink(*pin),
                pin->m_Flags & PIN_FLAG_EXPORTED,
                pin->m_Flags & PIN_FLAG_PUBLICIZED,
                PinTypeToColor(this, pin->GetValueType()));

            // [2] - Show pin name if it has one. Custom layout hidden name?
            if (!pin->m_Name.empty() && (!CheckNodeStyle(node, NodeStyle::Simple) || pin->m_Flags & PIN_FLAG_FORCESHOW) && (!node->CustomLayout() || m_isChildWindow)) 
            {
                ImGui::SameLine();
                show_pin_name(pin->m_Name);
            }
            // [3] - Show value/editor when pin is not linked to anything
            if (!m_Document->m_Blueprint.HasPinAnyLink(*pin) && !CheckNodeStyle(node, NodeStyle::Simple) && !(node->CustomLayout() || m_isChildWindow))
            {
                ImGui::SameLine();
                DrawPinValueWithEditor(*pin);
            }
            
            ed::EndPin();
            // [Debug Overlay] Show value of the pin if node is currently executed
            if (m_DebugOverlay) m_DebugOverlay->DrawInputPin(this, *pin);
            layout.NextRow();
        }
        if (CheckNodeStyle(node, NodeStyle::Simple))
        {
            auto nodeSize  = ed::GetNodeSize(node->m_ID);
            float font_size = ImGui::GetFontSize();
            layout.SetColumnAlignment(1.0f);
            layout.NextColumn();
            if (node->GetInputPins().size() > 1 || node->GetOutputPins().size() > 1)
                ImGui::Dummy(ImVec2(0, (nodeSize.y - font_size * 2) / 4));
            ImFont* font = HeaderFont();
            if (font) ImGui::PushFont(font);
            ImGui::TextUnformatted(nodeName.data());
            if (font) ImGui::PopFont();
        }
        else if (node->CustomLayout() && !m_isChildWindow)
        {
            layout.SetColumnAlignment(0.0f);
            layout.NextColumn();
            float zoom = ed::GetCurrentZoom();
            ImVec2 origin = ed::GetCurrentOrigin();
            if (node->DrawCustomLayout(ImGui::GetCurrentContext(), zoom, origin))
            {
                ed::SetNodeChanged(node->m_ID);
                if (m_CallBacks.BluePrintOnChanged)
                {
                    m_CallBacks.BluePrintOnChanged(BP_CB_PARAM_CHANGED, m_Document->m_Name, m_UserHandle);
                }
            }
        }
        else if (m_isChildWindow)
        {
            layout.SetColumnAlignment(0.f);
            layout.NextColumn();
            auto nodeSize  = ed::GetNodeSize(node->m_ID);
            ImGui::Dummy(ImVec2(0, (nodeSize.y - 64 - 32) / 2));
            node->DrawNodeLogo(ImGui::GetCurrentContext(), ImVec2(64, 64));
        }
        else
            layout.SetColumnAlignment(1.0f);
        layout.NextColumn();
        // Draw column with output pins.
        for (auto& pin : node->GetOutputPins())
        {
            // Add a bit of spacing to separate pins and make value not cramped
            ImGui::Spacing();
            // Output pin layout:
            //
            //    +-[1]------+-[2]---+
            //    |          |       |
            //    | Pin Name | Icon [X]
            //    |          |       |
            //    +----------+-------+
            ed::BeginPin(pin->m_ID, ed::PinKind::Output);
            // [X] - Tell editor to put pivot point in the middle of
            //       the right side of the pin. This is the point
            //       where link will be hooked to.
            //
            //       By default pivot is in pin center point which
            //       does not look good for blueprint nodes.
            ed::PinPivotAlignment(ImVec2(1.0f, 0.5f));
            // [1] - Show pin name if it has one. Custom layout hidden name?
            if (!pin->m_Name.empty() && (!CheckNodeStyle(node, NodeStyle::Simple) || pin->m_Flags & PIN_FLAG_FORCESHOW) && (!node->CustomLayout() || m_isChildWindow))
            {
                show_pin_name(pin->m_Name);
                ImGui::SameLine();
            }
            // [2] - Show icon
            Icon(iconSize,
                PinTypeToIconType(pin->GetType()),
                m_Document->m_Blueprint.HasPinAnyLink(*pin),
                pin->m_Flags & PIN_FLAG_EXPORTED,
                pin->m_Flags & PIN_FLAG_PUBLICIZED,
                PinTypeToColor(this, pin->GetValueType()));
            ed::EndPin();
            // [Debug Overlay] Show value of the pin if node is currently executed
            if (m_DebugOverlay) m_DebugOverlay->DrawOutputPin(this, *pin);
            layout.NextRow();
        }
        layout.End();
        if (!isDummy && !CheckNodeStyle(node, NodeStyle::Simple))
        {
            auto nodeStart = ed::GetNodePosition(node->m_ID);
            ImGui::SetCursorScreenPos(nodeStart);
            DrawNodeToolBar(node, &need_clone_node);
        }

#if DEBUG_NODE_DRAWING
        ImGui::Debug_DrawItemRect();
#endif
        if (node->m_NoBackGround)
            ed::PopStyleColor();
        ed::EndNode();
        if (isDummy)
            ed::PopStyleColor(1);
#if DEBUG_GROUP_NODE
        else if (isGrouped)
            ed::PopStyleColor(1);
#endif
#if DEBUG_NODE_DRAWING
        ImGui::Debug_DrawItemRect();
#endif
        // [Debug Overlay] Show cursor over node
        if (m_DebugOverlay) m_DebugOverlay->DrawNode(this, *node);
    }

    // Commit all links to editor
    CommitLinksToEditor();

    // Handle clone node
    if (need_clone_node)
    {
        ed::Suspend();
        LOGI("[HandleNodeToolBar] Clone from %" PRI_node, FMT_node(need_clone_node));
        auto nodeStart = ed::GetNodePosition(need_clone_node->m_ID);
        auto clone_node = m_Document->m_Blueprint.CloneNode(need_clone_node);
        ed::SetNodePosition(clone_node->m_ID, ImVec2(nodeStart.x + 40, nodeStart.y + 80));
        ed::Resume();
    }
    bool isThreadExecuting = m_Document->m_Blueprint.IsExecuting();
    bool isThreadPaused = m_Document->m_Blueprint.IsPaused();
    if (isThreadExecuting && !isThreadPaused && m_DebugOverlay && !m_isChildWindow)
    {
        g_Mutex.lock();
        m_Document->m_Blueprint.SetContextMonitor(m_DebugOverlay->GetContextMonitor());
        m_Document->m_Blueprint.ShowFlow();
        m_Document->m_Blueprint.SetContextMonitor(nullptr);
        g_Mutex.unlock();
    }

    // Handle new node menu last line drawing
    if (m_isNewNodePopuped && m_newNodeLinkPin != nullptr)
    {
        ed::DrawLastLine(m_Style == BluePrintStyle::BP_Style_Light);
    }
    if (m_DebugOverlay) m_DebugOverlay->End();
}

void BluePrintUI::DrawInfoTooltip()
{
    if (!m_Document || !ed::IsActive())
        return;

    auto hoveredNode = m_Document->m_Blueprint.FindNode(static_cast<ID_TYPE>(ed::GetHoveredNode().Get()));
    auto hoveredPin  = m_Document->m_Blueprint.FindPin(static_cast<ID_TYPE>(ed::GetHoveredPin().Get()));
    if (!hoveredNode && hoveredPin)
        hoveredNode = hoveredPin->m_Node;
    
    auto pinTooltip = [](const char* label, const Pin* pin, bool showNode)
    {
        auto isDummy = pin->m_Node->GetStyle() == NodeStyle::Dummy;
        ImGui::Text("%s %s", label, !pin->m_Name.empty() ? pin->m_Name.c_str() : "");
        ImGui::Bullet(); ImGui::Text("         ID: %u", pin->m_ID);
        if (pin->m_Link)
        {
            if (pin->m_Type == PinType::Flow)
                ImGui::Text("          ->: %u", pin->m_Link);
            else
                ImGui::Text("          <-: %u", pin->m_Link);
        }
        for (auto link_from : pin->m_LinkFrom)
        {
            if (pin->m_Type == PinType::Flow)
                ImGui::Text("          <-: %u", link_from);
            else
                ImGui::Text("          ->: %u", link_from);
        }
        if (pin->m_MappedPin)
        {
            ImGui::Text("      Mapped: %u", pin->m_MappedPin);
        }

        if (showNode && pin->m_Node)
        {
            auto isDummy = pin->m_Node->GetStyle() == NodeStyle::Dummy;
            auto nodeName = !isDummy ? pin->m_Node->GetName() : ((DummyNode *)pin->m_Node)->m_name + "*load fail*";
            ImGui::Bullet(); ImGui::Text("      Node: %" PRI_sv, FMT_sv(nodeName));
        }
        ImGui::Bullet(); ImGui::Text("      Type: %s", PinTypeToString(pin->GetType()).c_str());
        ImGui::Bullet(); ImGui::Text("Value Type: %s", PinTypeToString(pin->GetValueType()).c_str());
        if (!isDummy && !pin->m_MappedPin && pin->GetValueType() == PinType::Mat)
        {
            ImGui::TextUnformatted("=============ImMat===========");
            pin->m_Node->m_mutex.lock();
            PinValue pinValue;
            if (!pin->IsInput())
            {
                pinValue = pin->GetValue();
            }
            else
            {
                auto bp = pin->m_Node->m_Blueprint;
                if (bp)
                {
                    auto link = pin->GetLink(bp);
                    while (link && link->IsMappedPin())
                        link = link->GetLink(bp);
                    if (link)
                    {
                        link->m_Node->m_mutex.lock();
                        pinValue = link->GetValue();
                        link->m_Node->m_mutex.unlock();
                    }
                }
            }
            pin->m_Node->m_mutex.unlock();
            ImGui::ImMat mat;
            if (pinValue.GetType() == PinType::Mat)
                mat = pinValue.As<ImGui::ImMat>();
            if (!mat.empty())
            {
                ImGui::Text("        Width:%d", mat.w);
                ImGui::Text("       Height:%d", mat.h);
                ImGui::Text("     Channels:%d", mat.c);
                ImGui::Text("       Device:%s", mat.device == IM_DD_CPU ? "CPU" : 
                                                mat.device == IM_DD_VULKAN ? "Vulkan" :
                                                mat.device == IM_DD_VULKAN_IMAGE ? "Vulkan Image" : "Cuda");
                if (mat.device != 0)
                    ImGui::Text("          GPU:%d", mat.device_number);
                ImGui::Text("    Data type:%s", mat.type == IM_DT_INT8 ? "Int8" :
                                                mat.type == IM_DT_INT16 ? "Int16" :
                                                mat.type == IM_DT_INT32 ? "Int32" :
                                                mat.type == IM_DT_INT64 ? "Int64" :
                                                mat.type == IM_DT_FLOAT16 ? "Float 16" : 
                                                mat.type == IM_DT_FLOAT32 ? "Float" :
                                                mat.type == IM_DT_FLOAT64 ? "Double" : "Unknown");
                ImGui::Text("       Format:%s", mat.flags & IM_MAT_FLAGS_AUDIO_FRAME ? "Audio" :
                                                mat.color_format == IM_CF_GRAY ? "Gray/Mono" :
                                                mat.color_format == IM_CF_BGR ? "BGR" :
                                                mat.color_format == IM_CF_ABGR ? "ABGR" :
                                                mat.color_format == IM_CF_BGRA ? "BGRA" :
                                                mat.color_format == IM_CF_RGB ? "RGB" :
                                                mat.color_format == IM_CF_ARGB ? "ARGB" :
                                                mat.color_format == IM_CF_RGBA ? "RGBA" :
                                                mat.color_format == IM_CF_YUV420 ? "YUV420" :
                                                mat.color_format == IM_CF_YUV422 ? "YUV422" :
                                                mat.color_format == IM_CF_YUV444 ? "YUV444" :
                                                mat.color_format == IM_CF_YUVA ? "YUVA" :
                                                mat.color_format == IM_CF_NV12 ? "NV12" : 
                                                mat.color_format == IM_CF_P010LE ? "P010LE" :"Unknown");
                if (mat.flags & IM_MAT_FLAGS_VIDEO_FRAME)
                {
                    ImGui::Text("   Frame Type:%s", mat.flags & IM_MAT_FLAGS_VIDEO_FRAME_I ? "I" : 
                                                    mat.flags & IM_MAT_FLAGS_VIDEO_FRAME_P ? "P" : 
                                                    mat.flags & IM_MAT_FLAGS_VIDEO_FRAME_B ? "B" : "Unknown");
                    ImGui::Text("    Frame HDR:%s", mat.flags & IM_MAT_FLAGS_VIDEO_HDR_PQ ? "PQ" : 
                                                    mat.flags & IM_MAT_FLAGS_VIDEO_HDR_HLG ? "HLG" : "SDR");
                    ImGui::Text("   Interlaced:%s", mat.flags & IM_MAT_FLAGS_VIDEO_INTERLACED ? "Interlaced" : "no");
                }
                ImGui::Text("    TimeStamp:%.6f", mat.time_stamp);
            }
            else
            {
                ImGui::TextUnformatted("      *Empty*");
            }
            ImGui::TextUnformatted("=============================");
        }
        if (!isDummy && !pin->m_MappedPin && pin->GetValueType() == PinType::Array)
        {
            ImGui::TextUnformatted("=============Array===========");
            pin->m_Node->m_mutex.lock();
            PinValue pinValue;
            if (!pin->IsInput())
            {
                pinValue = pin->GetValue();
            }
            else
            {
                auto bp = pin->m_Node->m_Blueprint;
                if (bp)
                {
                    auto link = pin->GetLink(bp);
                    while (link && link->IsMappedPin())
                        link = link->GetLink(bp);
                    if (link)
                    {
                        link->m_Node->m_mutex.lock();
                        pinValue = link->GetValue();
                        link->m_Node->m_mutex.unlock();
                    }
                }
            }
            pin->m_Node->m_mutex.unlock();
            imgui_json::array array;
            if (pinValue.GetType() == PinType::Array)
                array = pinValue.As<imgui_json::array>();
            if (array.size() > 0)
            {
                auto type = array[0].type();
                ImGui::Text("        Element Size:%zu", array.size());
                ImGui::Text("        Element Type:%s", edd::Serialization::ToString(type).c_str());
            }
            else
            {
                ImGui::TextUnformatted("      *Empty*");
                ImGui::TextUnformatted("             ");
            }
            ImGui::TextUnformatted("=============================");
        }
        string flags;
        if (pin->IsMappedPin())
            flags += "mapped, ";
        if (pin->m_Flags & PIN_FLAG_EXPORTED)
            flags += "exported, ";
        if (pin->m_Flags & PIN_FLAG_PUBLICIZED)
            flags += "publicized, ";
        if (pin->IsLinked())
            flags += "linked, ";
        if (pin->IsInput())
            flags += "input, ";
        if (pin->IsOutput())
            flags += "output, ";
        if (pin->IsProvider())
            flags += "provider, ";
        if (pin->IsReceiver())
            flags += "receiver, ";
        if (!flags.empty())
            flags = flags.substr(0, flags.size() - 2);
        ImGui::Bullet(); ImGui::Text("   Flags: %s", flags.c_str());
    };

    ImGui::SetNextWindowBgAlpha(0.75f);
    if (hoveredNode)
    {
        auto isDummy = hoveredNode->GetStyle() == NodeStyle::Dummy;
        auto nodeTypeInfo = hoveredNode->GetTypeInfo();
        auto nodeName = !isDummy ? hoveredNode->GetName() : ((DummyNode *)hoveredNode)->m_name + "*load fail*";
        auto nodeTypeName = !isDummy ? nodeTypeInfo.m_Name : ((DummyNode *)hoveredNode)->m_type_name;
        auto nodeType = !isDummy ? hoveredNode->GetType() : ((DummyNode *)hoveredNode)->m_type;
        auto nodeStyle = !isDummy ? hoveredNode->GetStyle() : ((DummyNode *)hoveredNode)->m_style;
        auto nodeCatalog = !isDummy ? hoveredNode->GetCatalog() : ((DummyNode *)hoveredNode)->m_catalog;
        auto nodeVersion = hoveredNode->GetVersion();
        ed::Suspend();
        if (hoveredNode->m_IconHovered >= 0)
        {
            ImGui::BeginTooltip();
            switch (hoveredNode->m_IconHovered)
            {
                case 0: ImGui::TextUnformatted("Node Clone"); break;
                case 1: ImGui::TextUnformatted("Node Delete"); break;
                case 2: ImGui::TextUnformatted("Node Setting"); break;
                case 3: ImGui::TextUnformatted("Save Group"); break;
                case 4: if (hoveredNode->m_Enabled) ImGui::TextUnformatted("Disable"); else ImGui::TextUnformatted("Enable"); break;
                default: break;
            }
            ImGui::EndTooltip();
        }
        else if (m_isShowInfoTooltips)
        {
            ImGui::BeginTooltip();
            if (hoveredPin)
            {
                if (ImGui::IsMouseDoubleClicked(0))
                {
                    LOGI("[Pin Event:] %" PRI_pin " be double clicked", FMT_pin(hoveredPin));
                    if (!hoveredPin->IsMappedPin())
                    {
                        if (hoveredPin->m_Flags & PIN_FLAG_PUBLICIZED)
                        {
                            hoveredPin->m_Flags &= ~PIN_FLAG_PUBLICIZED;
                        }
                        else
                        {
                            hoveredPin->m_Flags |= PIN_FLAG_PUBLICIZED;
                        }
                        ed::SetPinChanged(hoveredPin->m_ID);
                        m_Document->m_IsModified = true;
                    }
                }
                pinTooltip("Pin:", hoveredPin, false);
                ImGui::Separator();
            }
            ImGui::Text("Node: %" PRI_sv, FMT_sv(nodeName));
            ImGui::Bullet(); ImGui::Text(" Node ID: %u", hoveredNode->m_ID);
            ImGui::Bullet(); ImGui::Text(" Type ID: 0x%08" PRIX32, nodeTypeInfo.m_ID);
            ImGui::Bullet(); ImGui::Text("TypeName: %" PRI_sv, FMT_sv(nodeTypeName));
            ImGui::Bullet(); ImGui::Text(" Version: %" PRI_sv, FMT_sv(NodeVersionToString(nodeVersion)));
            ImGui::Bullet(); ImGui::Text("    Type: %s", NodeTypeToString(nodeType).c_str());
            ImGui::Bullet(); ImGui::Text("   Style: %s", NodeStyleToString(nodeStyle).c_str());
            ImGui::Bullet(); ImGui::Text(" Catalog: %s", nodeCatalog.c_str());
            ImGui::Bullet(); ImGui::Text("   Z-Pos: %.1f", ed::GetNodeZPosition(hoveredNode->m_ID));
            if (hoveredNode->m_GroupID != 0)
            {
                ImGui::Bullet(); ImGui::Text(" Grouped: 0x%08" PRIX32, hoveredNode->m_GroupID);
            }
            else
            {
                ImGui::Bullet(); ImGui::Text(" Non-Grouped");
            }
            //if (m_Document->m_Blueprint.IsExecuting())
            {
                ImGui::Separator();
                ImGui::Bullet(); ImGui::Text("     Hits: %s", std::to_string(hoveredNode->m_Hits).c_str());
                std::ostringstream oss;
                oss << std::setprecision(hoveredNode->m_Tick > 1000 ? 6 : 3) << (hoveredNode->m_Tick > 1000000 ? hoveredNode->m_Tick / 1000000.0 :
                                        hoveredNode->m_Tick > 1000 ? hoveredNode->m_Tick / 1000.0 :
                                        hoveredNode->m_Tick);
                std::string tick_text = oss.str() + (hoveredNode->m_Tick > 1000000 ? "s" : hoveredNode->m_Tick > 1000 ? "ms" : "us");
                ImGui::Bullet(); ImGui::Text("    Ticks: %s", tick_text.c_str());
                ImGui::Bullet(); ImGui::Text("Node Time: %.3fms", hoveredNode->m_NodeTimeMs);
            }
            ImGui::EndTooltip();
        }
        ed::Resume();
    }
    else if (auto hoveredLinkId = ed::GetHoveredLink())
    {
        if (m_isShowInfoTooltips)
        {
            ed::PinId firstPinId, secondPinId;
            ed::GetLinkPins(hoveredLinkId, &firstPinId, &secondPinId);
            // inverse flow pin order since we create link using sample mode
            Pin * startPin = nullptr;
            Pin * endPin = nullptr;
            auto firstPin = m_Document->m_Blueprint.FindPin(static_cast<ID_TYPE>(firstPinId.Get()));
            auto secondPin = m_Document->m_Blueprint.FindPin(static_cast<ID_TYPE>(secondPinId.Get()));
            if (firstPin && secondPin)
            {
                if (firstPin->GetType() == PinType::Flow && secondPin->GetType() == PinType::Flow)
                {
                    startPin = firstPin;
                    endPin = secondPin;
                }
                else
                {
                    startPin = secondPin;
                    endPin = firstPin;
                }
                ed::Suspend();
                ImGui::BeginTooltip();
                ImGui::Text("Link ID: 0x%08" PRIX32, startPin->m_ID);
                ImGui::Text("Type: %s", PinTypeToString(startPin->GetValueType()).c_str());
                ImGui::Separator();
                pinTooltip("Start Pin:", startPin, true);
                ImGui::Separator();
                pinTooltip("End Pin:", endPin, true);
                ImGui::EndTooltip();
                ed::Resume();
            }
        }
    }
}

void BluePrintUI::ShowDialogs()
{
    if (!m_Document)
        return;
    ed::Suspend();
    m_ContextMenu.Show(*this);
    m_NodeContextMenu.Show(*this);
    m_PinContextMenu.Show(*this);
    m_LinkContextMenu.Show(*this);
    m_NodeDeleteDialog.Show(*this);
    m_NodeCreateDialog.Show(*this);
    m_NodeSettingDialog.Show(*this);
    ed::Resume();
}

void BluePrintUI::FileDialogs()
{
    if (!m_Document)
        return;
    auto& io = ImGui::GetIO();
    auto viewport = ImGui::GetWindowViewport();
    ImVec2 maxSize = viewport->Size;
    ImVec2 minSize = maxSize * 0.5f;
    if (io.ConfigFlags & ImGuiConfigFlags_ViewportsEnable)
        io.ConfigViewportsNoDecoration = true;
    if (m_FileDialog.Display("##OpenFileDlgKey", ImGuiWindowFlags_NoCollapse, minSize, maxSize))
    {
        if (m_FileDialog.IsOk())
        {
            string error;
            auto filePathName = m_FileDialog.GetFilePathName();
            if (!File_Open(filePathName, &error) && !error.empty())
            {
                LOGE("%s", error.c_str());
            }
        }
        m_FileDialog.Close();
    }
    if (m_FileDialog.Display("##SaveFileDlgKey", ImGuiWindowFlags_NoCollapse, minSize, maxSize))
	{
        if (m_FileDialog.IsOk())
		{
            auto filePathName = m_FileDialog.GetFilePathName();
            if (!File_SaveAsEx(filePathName))
            {
                LOGE("Save file failed %s", filePathName.c_str());
            }
            else
            {
                m_Document->SetPath(filePathName);
                if (!m_isChildWindow)
                {
                    auto mostRecentlyOpenFiles = ImGui::MostRecentlyUsedList("BluePrintOpenList");
                    mostRecentlyOpenFiles.Add(filePathName);
                }
            }
        }
        m_FileDialog.Close();
    }
    if (m_FileDialog.Display("##SaveGroupDlgKey", ImGuiWindowFlags_NoCollapse, minSize, maxSize))
    {
        if (m_FileDialog.IsOk())
		{
            GroupNode * node = (GroupNode *)m_FileDialog.GetUserDatas();
            auto filePathName = m_FileDialog.GetFilePathName();
            if (node)
            {
                node->SaveGroup(filePathName);
            }
        }
        m_FileDialog.Close();
    }
    if (m_FileDialog.Display("##ImportGroupDlgKey", ImGuiWindowFlags_NoCollapse, minSize, maxSize))
    {
        if (m_FileDialog.IsOk())
        {
            string error;
            auto filePathName = m_FileDialog.GetFilePathName();
            ImVec2 * pos = (ImVec2 *)m_FileDialog.GetUserDatas();
            if (!File_Import(filePathName, *pos, &error) && !error.empty())
            {
                LOGE("%s", error.c_str());
            }
        }
        m_FileDialog.Close();
    }
    if (io.ConfigFlags & ImGuiConfigFlags_ViewportsEnable)
        io.ConfigViewportsNoDecoration = false;
}

Node* BluePrintUI::ShowNewNodeMenu(ImVec2 popupPosition, std::string catalog_filter)
{
    Node* node = nullptr;
    if (!m_Document)
        return node;
    static string filter_string = "";
    ImGui::PushStyleVar(ImGuiStyleVar_FrameBorderSize, 1.0f);
    if (ImGui::InputText(ICON_NODE_SEARCH "##search_string_value", (char*)filter_string.data(), filter_string.size() + 1, ImGuiInputTextFlags_CallbackEdit | ImGuiInputTextFlags_EnterReturnsTrue | ImGuiInputTextFlags_CallbackResize, [](ImGuiInputTextCallbackData* data) -> int
    {
        if (data->EventFlag == ImGuiInputTextFlags_CallbackResize)
        {
            auto& stringValue = *static_cast<string*>(data->UserData);
            ImVector<char>* my_str = (ImVector<char>*)data->UserData;
            IM_ASSERT(stringValue.data() == data->Buf);
            stringValue.resize(data->BufSize);
            data->Buf = (char*)stringValue.data();
        }
        else if (data->EventFlag == ImGuiInputTextFlags_CallbackEdit)
        {
            auto& stringValue = *static_cast<string*>(data->UserData);
            stringValue = std::string(data->Buf);
        }
        return 0;
    }, &filter_string))
    {
        filter_string.resize(strlen(filter_string.c_str()));
    }
    ImGui::PopStyleVar();
    ImGui::Separator();
    auto registryNode = m_Document->m_Blueprint.GetNodeRegistry()->GetTypes();
    auto registryCatalog = m_Document->m_Blueprint.GetNodeRegistry()->GetCatalogs();
    bool need_root = true;
    int start_level = 0;
    std::vector<const BluePrint::NodeTypeInfo*> nodes;
    if (!catalog_filter.empty())
    {
        auto catalog_filters = GetCatalogInfo(catalog_filter);
        if (catalog_filters.size() > 0)
        {
            need_root = false;
            start_level = catalog_filters.size();
        }
        std::vector<const NodeTypeInfo *> array;
        for (auto nodetype : registryNode)
        {
            auto catalogs = GetCatalogInfo(nodetype->m_Catalog);
            if (catalogs.size() > 0 && catalog_filters.size() > 0 && catalogs[0].compare("Dummy") != 0)
            {
                if (catalogs[0].compare(catalog_filters[0]) == 0)
                {
                    if (catalogs.size() > 1 && catalog_filters.size() > 1)
                    {
                        if (catalogs[1].compare(catalog_filters[1]) == 0)
                        {
                            if (catalogs.size() > 2 && catalog_filters.size() > 2)
                            {
                                if (catalogs[2].compare(catalog_filters[2]) == 0)
                                    array.push_back(nodetype);
                            }
                            else
                                array.push_back(nodetype);
                        }
                    }
                    else
                        array.push_back(nodetype);
                }
                else if (nodetype->m_Style == NodeStyle::Comment || nodetype->m_Style == NodeStyle::Group)
                {
                    array.push_back(nodetype);
                }
            }
        }
        string low_case_filter_str = filter_string.size() > 0 ? to_lower(filter_string) : "";
        for (auto nodetype : array)
        {
            string low_case_node_type_name = to_lower(nodetype->m_Name);
            if (filter_string.size() == 0 || low_case_node_type_name.find(low_case_filter_str) != string::npos)
            {
                nodes.push_back(nodetype);
            }
        }
    }
    else if (filter_string.size() > 0)
    {
        string low_case_filter_str = to_lower(filter_string);
        for (size_t i = 0; i < registryCatalog.size(); i++)
        {
            auto catalog = registryCatalog[i];
            std::vector<const NodeTypeInfo *> array;
            for (auto nodetype : registryNode)
            {
                auto catalogs = GetCatalogInfo(nodetype->m_Catalog);
                if (catalogs.size() > 0 && catalogs[0].compare("Dummy") != 0 && catalogs[0].compare(catalog) == 0)
                    array.push_back(nodetype);
            }
            for (auto nodetype : array)
            {
                string low_case_node_type_name = to_lower(nodetype->m_Name);
                if (low_case_node_type_name.find(low_case_filter_str) != string::npos)
                {
                    nodes.push_back(nodetype);
                }
            }
        }
    }
    else
    {
        for (auto nodetype : registryNode)
        {
            if (nodetype->m_Catalog.compare("Dummy") != 0)
                nodes.push_back(nodetype);
        }
    }
    std::sort(nodes.begin(), nodes.end(), [](const NodeTypeInfo * a, const NodeTypeInfo * b) {
        return a->m_Name < b->m_Name;
    });

    auto AddNodeMenu = [&](void* data, bool tree_view = true, bool is_system_node = false)
    {
        const BluePrint::NodeTypeInfo* nodetype = (const BluePrint::NodeTypeInfo*)data;
        std::string menu_label;
        if (tree_view)
        {
            if (is_system_node)
            {
                ImGui::TextUnformatted(ICON_BP_ZOOM_IN); 
                ImGui::SameLine();
            }
            else 
                ImGui::Bullet();
            menu_label = nodetype->m_Name;
        }
        else
        {
            auto catalogs = GetCatalogInfo(nodetype->m_Catalog);
            for (auto label : catalogs)
                menu_label += label + " " + ICON_NODE_NEXT + " ";
            menu_label += nodetype->m_Name;
        }
        
        if (ImGui::MenuItem(menu_label.c_str(), nullptr, false, true, nodetype->m_Type == NodeType::External ? ICON_NODE_DLL : nullptr))
        {
            auto transaction = m_Document->BeginUndoTransaction("CreateNode");
            node = m_Document->m_Blueprint.CreateNode(nodetype->m_ID);
            LOGI("[NodeCreate] %" PRI_node " created", FMT_node(node));
            if (popupPosition.x == 0 || popupPosition.y == 0)
            {
                ImVec2 w_pos = ImGui::GetCursorPos();
                ImVec2 c_pos = ImGui::GetWindowPos();
                popupPosition = ImVec2(w_pos.x + c_pos.x, w_pos.y + c_pos.y);
            }
            auto nodePosition = ed::ScreenToCanvas(popupPosition);
            ed::SetNodePosition(node->m_ID, nodePosition);
            ed::SelectNode(node->m_ID);
            transaction->AddAction("%" PRI_node " created", FMT_node(node));
            m_isNewNodePopuped = false;
            m_newNodeLinkPin = nullptr;
        }
    };

    if (filter_string.size() > 0)
    {
        for (auto nodetype : nodes)
        {
            AddNodeMenu((void *)nodetype, false);
        }
    }
    else
    {
        // make node type as tree, max 4 levels
        ImGui::ImTree node_tree;
        node_tree.name = "Nodes";
        if (need_root)
        {
            for (size_t i = 0; i < registryCatalog.size(); i++)
            {
                auto catalog = registryCatalog[i];
                auto catalogs = GetCatalogInfo(catalog);
                if (catalogs.size() > 0 && catalogs[0].compare("Dummy") != 0)
                {
                    auto children = node_tree.FindChildren(catalogs[0]);
                    if (!children)
                    {
                        ImGui::ImTree subtree(catalogs[0]);
                        node_tree.childrens.push_back(subtree);
                    }
                }
            }
        }
        for (auto type : nodes)
        {
            auto catalog = BluePrint::GetCatalogInfo(type->m_Catalog);
            if (!catalog.size())
                continue;
            ImGui::ImTree * root = need_root ? node_tree.FindChildren(catalog[0]) : &node_tree;
            if (catalog.size() > 1)
            {
                auto children = root->FindChildren(catalog[1]);
                if (!children)
                {
                    ImGui::ImTree subtree(catalog[1]);
                    if (catalog.size() > 2)
                    {
                        ImGui::ImTree sub_sub_tree(catalog[2]);
                        ImGui::ImTree end_sub(type->m_Name, (void *)type);
                        sub_sub_tree.childrens.push_back(end_sub);
                        subtree.childrens.push_back(sub_sub_tree);
                    }
                    else
                    {
                        ImGui::ImTree end_sub(type->m_Name, (void *)type);
                        subtree.childrens.push_back(end_sub);
                    }

                    root->childrens.push_back(subtree);
                }
                else
                {
                    if (catalog.size() > 2)
                    {
                        auto sub_children = children->FindChildren(catalog[2]);
                        if (!sub_children)
                        {
                            ImGui::ImTree subtree(catalog[2]);
                            ImGui::ImTree end_sub(type->m_Name, (void *)type);
                            subtree.childrens.push_back(end_sub);
                            children->childrens.push_back(subtree);
                        }
                        else
                        {
                            ImGui::ImTree end_sub(type->m_Name, (void *)type);
                            sub_children->childrens.push_back(end_sub);
                        }
                    }
                    else
                    {
                        ImGui::ImTree end_sub(type->m_Name, (void *)type);
                        children->childrens.push_back(end_sub);
                    }
                }
            }
            else
            {
                ImGui::ImTree end_sub(type->m_Name, (void *)type);
                root->childrens.push_back(end_sub);
            }
        }

        // draw node tree
        ImGui::ImTree * start = &node_tree;
        for (int i = 0; i < start_level - 1; i++)
        {
            for (int j = 0; j < start->childrens.size(); j++)
            {
                if (start->childrens[j].data)
                    continue;
                else
                {
                    start = &start->childrens[j];
                    break;
                }
            }
        }

        for (auto sub : start->childrens)
        {
            if (sub.data)
            {
                AddNodeMenu(sub.data);
            }
            else if (ImGui::BeginMenu(sub.name.c_str()))
            {
                for (auto sub_2 : sub.childrens)
                {
                    if (sub_2.data)
                    {
                        AddNodeMenu(sub_2.data);
                    }
                    else if (ImGui::BeginMenu(sub_2.name.c_str()))
                    {
                        for (auto sub_3 : sub_2.childrens)
                        {
                            if (sub_3.data)
                            {
                                AddNodeMenu(sub_3.data);
                            }
                            else if (ImGui::BeginMenu(sub_3.name.c_str()))
                            {
                                for (auto sub_4 : sub_3.childrens)
                                {
                                    if (sub_4.data)
                                    {
                                        AddNodeMenu(sub_4.data);
                                    }
                                    else
                                    {
                                        continue;
                                    }
                                }
                                ImGui::EndMenu();
                            }
                        }
                        ImGui::EndMenu();
                    }
                }
                ImGui::EndMenu();
            }
        }

        // draw utils node
        if (&node_tree != start)
        {
            for (auto sub : node_tree.childrens)
            {
                if (sub.data)
                {
                    AddNodeMenu(sub.data, true, true);
                }
            }
        }
    }
    return node;
}

void BluePrintUI::HandleCreateAction(uint32_t flag)
{
    if (!m_Document)
        return;

    ItemBuilder itemBuilder;
    if (!itemBuilder)
        return;

    m_isNewNodePopuped = false;
    m_newNodeLinkPin = nullptr;

    if (auto linkBuilder = itemBuilder.QueryNewLink())
    {
        auto startPin = m_Document->m_Blueprint.FindPin(static_cast<ID_TYPE>(linkBuilder->m_StartPinId.Get()));
        auto endPin   = m_Document->m_Blueprint.FindPin(static_cast<ID_TYPE>(linkBuilder->m_EndPinId.Get()));
        // Editor return pins in order draw by the user. It is up to the
        // user to determine if it is valid. In blueprints we accept only links
        // from receivers to providers. Other graph types may allow bi-directional
        // links between nodes and this ordering make this feature possible.
        if (endPin->IsReceiver() && startPin->IsProvider())
            ImSwap(startPin, endPin);
        if (auto canLinkResult = startPin->CanLinkTo(*endPin))
        {
            ed::Suspend();
            ImGui::BeginTooltip();
            ImGui::TextUnformatted("Valid Link"); ImGui::SameLine();
            ImGui::Text("%s%s",
                canLinkResult.Reason().empty() ? "" : ": ",
                canLinkResult.Reason().empty() ? "" : canLinkResult.Reason().c_str());
            ImGui::Separator();
            ImGui::TextUnformatted("From:");
            ImGui::Bullet(); ImGui::Text("%" PRI_pin, FMT_pin(startPin));
            ImGui::Bullet(); ImGui::Text("%" PRI_node, FMT_node(startPin->m_Node));
            ImGui::TextUnformatted("To:");
            ImGui::Bullet(); ImGui::Text("%" PRI_pin, FMT_pin(endPin));
            ImGui::Bullet(); ImGui::Text("%" PRI_node, FMT_node(endPin->m_Node));
            ImGui::EndTooltip();
            ed::Resume();
            if (linkBuilder->Accept())
            {
                auto transaction = m_Document->BeginUndoTransaction("Create Link");
                if (startPin->LinkTo(*endPin))
                {
                    LOGI("[HandleCreateAction] %" PRI_pin " linked with %" PRI_pin, FMT_pin(startPin), FMT_pin(endPin));
                    if (m_CallBacks.BluePrintOnChanged)
                    {
                        auto ret = m_CallBacks.BluePrintOnChanged(BP_CB_Link, m_Document->m_Name, m_UserHandle);
                        if (startPin->m_Type == PinType::Flow && ret == BP_CBR_AutoLink)
                        {
                            auto out_pin = startPin->m_Node->GetAutoLinkOutputDataPin();
                            auto in_pin = endPin->m_Node->GetAutoLinkInputDataPin();
                            if (in_pin.size() && out_pin.size() && in_pin.size() == out_pin.size())
                            {
                                for (int i = 0; i < in_pin.size(); i++)
                                {
                                    in_pin[i]->LinkTo(*out_pin[i]);
                                }
                            }
                        }
                    }
                }
                else
                    transaction->Discard();
            }
        }
        else
        {
            ed::Suspend();
            ImGui::BeginTooltip();
            ImGui::TextUnformatted("Invalid Link:"); ImGui::SameLine();
            ImGui::Text(" %s", canLinkResult.Reason().c_str());
            ImGui::EndTooltip();
            ed::Resume();
            linkBuilder->Reject();
        }
    }
    else if (auto nodeBuilder = itemBuilder.QueryNewNode())
    {
        // Arguably creation of node is simpler than a link.
        ed::Suspend();
        ImGui::SetTooltip("Create Node...");
        ed::Resume();
        // Node builder accept return true when user release mouse button.
        // When this happen we request CreateNodeDialog to open.
        if (nodeBuilder->Accept())
        {
            // Get node from which link was pulled (if any). After creating
            // node we will try to make link with first matching pin of the node.
            auto pin = m_Document->m_Blueprint.FindPin(static_cast<ID_TYPE>(nodeBuilder->m_PinId.Get()));
            ed::Suspend();
            LOGI("[HandleCreateAction] Open CreateNodeDialog");
            m_NodeCreateDialog.Open(pin, flag);
            m_isNewNodePopuped = true;
            m_newNodeLinkPin = pin;
            ed::Resume();
        }
    }
}

void BluePrintUI::HandleDestroyAction()
{
    if (!m_Document)
        return;
    ItemDeleter itemDeleter;
    if (!itemDeleter)
        return;
    auto deferredTransaction = m_Document->GetDeferredUndoTransaction("Destroy Action");
    vector<Node*> nodesToDelete;
    vector<std::pair<Pin *, Pin *>> relink_pairs;
    uint32_t brokenLinkCount = 0;
    // Process all nodes marked for deletion
    while (auto nodeDeleter = itemDeleter.QueryDeletedNode())
    {
        deferredTransaction->Begin("Delete Item");
        auto node = m_Document->m_Blueprint.FindNode(static_cast<ID_TYPE>(nodeDeleter->m_NodeId.Get()));
        // Remove node, pass 'true' so links attached to node will also be queued for deletion.
        if (node && nodeDeleter->Accept(node->GetStyle() != NodeStyle::Group))
        {
            // Infor Node to handle delete before serv links
            node->OnNodeDelete();
            if (m_CallBacks.BluePrintOnChanged)
            {
                auto ret = m_CallBacks.BluePrintOnChanged(BP_CB_NODE_DELETED, m_Document->m_Name, m_UserHandle);
                if (ret == BP_CBR_AutoLink)
                {
                    // need mark re-link pairs
                    auto in_flow_pin = node->GetAutoLinkInputFlowPin();
                    auto in_data_pin = node->GetAutoLinkInputDataPin();
                    auto out_flow_pin = node->GetAutoLinkOutputFlowPin();
                    auto out_data_pin = node->GetAutoLinkOutputDataPin();
                    // Check flow pin relink pair 
                    if (in_flow_pin && out_flow_pin &&
                        in_flow_pin->m_LinkFrom.size() > 0 &&
                        out_flow_pin->m_LinkPin)
                    {
                        for (auto from_pin : in_flow_pin->m_LinkFrom)
                        {
                            std::pair<Pin *, Pin *> re_link;
                            auto pin = m_Document->m_Blueprint.GetPinFromID(from_pin);
                            if (pin)
                            {
                                std::pair<Pin *, Pin *> re_link(pin, out_flow_pin->m_LinkPin);
                                relink_pairs.push_back(re_link);
                            }
                        }
                    }
                    // Check data pin relink pair 
                    if (in_data_pin.size() > 0 && out_data_pin.size() > 0 && in_data_pin.size() == out_data_pin.size())
                    {
                        for (int i = 0; i < in_data_pin.size(); i++)
                        {
                            auto in_pin = in_data_pin[i];
                            auto out_pin = out_data_pin[i];
                            if (in_pin->m_LinkPin && out_pin->m_LinkFrom.size() > 0)
                            {
                                for (auto from_pin : out_pin->m_LinkFrom)
                                {
                                    std::pair<Pin *, Pin *> re_link;
                                    auto pin = m_Document->m_Blueprint.GetPinFromID(from_pin);
                                    if (pin)
                                    {
                                        std::pair<Pin *, Pin *> re_link(pin, in_pin->m_LinkPin);
                                        relink_pairs.push_back(re_link);
                                    }
                                }
                            }
                        }
                    }
                }
            }
            // Queue nodes for deletion. We need to serve links first to avoid crash.
            nodesToDelete.push_back(node);
        }
    }
    // Process all links marked for deletion
    while (auto linkDeleter = itemDeleter.QueryDeleteLink())
    {
        deferredTransaction->Begin("Delete Item");
        if (linkDeleter->Accept())
        {
            auto pins = m_Document->m_Blueprint.GetPins();
            auto startPin = m_Document->m_Blueprint.FindPin(static_cast<ID_TYPE>(linkDeleter->m_StartPinId.Get()));
            if (startPin != nullptr && startPin->IsLinked())
            {
                auto linkedPin = startPin->GetLink();
                if (std::find(pins.begin(), pins.end(), linkedPin) != pins.end())
                {
                    LOGI("[HandleDestroyAction] %" PRI_pin " unlinked from %" PRI_pin, FMT_pin(startPin), FMT_pin(linkedPin));
                    startPin->Unlink();
                    if (m_CallBacks.BluePrintOnChanged)
                    {
                        auto ret = m_CallBacks.BluePrintOnChanged(BP_CB_Unlink, m_Document->m_Name, m_UserHandle);
                    }
                    ++brokenLinkCount;
                }
            }
        }
    }
    // After links was removed, now it is safe to delete nodes.
    for (auto node : nodesToDelete)
    {
        LOGI("[HandleDestroyAction] %" PRI_node, FMT_node(node));
        m_Document->m_Blueprint.DeleteNode(node);
    }
    // Check if we have re-link pin
    for (auto pair : relink_pairs)
    {
        pair.first->LinkTo(*pair.second);
    }
    if (!nodesToDelete.empty() || brokenLinkCount)
    {
        LOGI("[HandleDestroyAction] %" PRIu32 " node%s deleted, %" PRIu32 " link%s broken",
            static_cast<uint32_t>(nodesToDelete.size()), nodesToDelete.size() != 1 ? "s" : "",
            brokenLinkCount, brokenLinkCount != 1 ? "s" : "");
    }
}

void BluePrintUI::HandleContextMenuAction(uint32_t flag)
{
    if (!m_Document)
        return;
    
    if (m_Document->m_Blueprint.IsExecuting() && !m_Document->m_Blueprint.IsPaused())
        return;

    if (ed::ShowBackgroundContextMenu())
    {
        ed::Suspend();
        LOGI("[HandleContextMenuAction] Show Background Context Menu");
        if ((flag & BluePrintFlag::BluePrintFlag_All) != 0)
        {
            m_ContextMenu.Open();
        }
        else
        {
            CleanStateStorage();
            if ((flag & BluePrintFlag::BluePrintFlag_Filter) != 0)
            {
                ImGui::OpenPopup("##create_filter_node");
            }
            else if ((flag & BluePrintFlag::BluePrintFlag_Fusion) != 0)
            {
                ImGui::OpenPopup("##create_fusion_node");
            }
            else if ((flag & BluePrintFlag::BluePrintFlag_System) != 0)
            {
                ImGui::OpenPopup("##create_system_node");
            }
        }
        ed::Resume();
    }

    if ((flag & BluePrintFlag::BluePrintFlag_All) != 0)
    {
        ed::NodeId contextNodeId;
        if (ed::ShowNodeContextMenu(&contextNodeId))
        {
            auto node = m_Document->m_Blueprint.FindNode(static_cast<uint32_t>(contextNodeId.Get()));

            ed::Suspend();
            LOGI("[HandleContextMenuAction] Open NodeContextMenu for %" PRI_node, FMT_node(node));
            m_NodeContextMenu.Open(node);
            ed::Resume();
        }
    }

    ed::PinId contextPinId;
    if (ed::ShowPinContextMenu(&contextPinId))
    {
        auto pin = m_Document->m_Blueprint.FindPin(static_cast<uint32_t>(contextPinId.Get()));

        ed::Suspend();
        LOGI("[HandleContextMenuAction] Open PinContextMenu for %" PRI_pin, FMT_pin(pin));
        m_PinContextMenu.Open(pin);
        ed::Resume();
    }

    ed::LinkId contextLinkId;
    if (ed::ShowLinkContextMenu(&contextLinkId))
    {
        auto pin = m_Document->m_Blueprint.FindPin(static_cast<ID_TYPE>(contextLinkId.Get()));

        ed::Suspend();
        LOGI("[HandleContextMenuAction] Open LinkContextMenu for %" PRI_pin, FMT_pin(pin));
        m_LinkContextMenu.Open(pin);
        ed::Resume();
    }
}

bool BluePrintUI::File_IsOpen()
{
    return m_Document != nullptr;
}

bool BluePrintUI::File_IsModified()
{
    return m_Document->m_IsModified;
}

void BluePrintUI::File_MarkModified()
{
    if (m_Document->m_IsModified)
        return;

    m_Document->m_IsModified = true;
}

void BluePrintUI::InitFileDialog(const char * bookmark_path)
{
#ifdef USE_BOOKMARK
	// load bookmarks
	m_BookMarkPath = bookmark_path ? std::string(bookmark_path) : "";
	std::ifstream docFile(bookmark_path, std::ios::in);
	if (docFile.is_open())
	{
		std::stringstream strStream;
		strStream << docFile.rdbuf();//read the file
		m_FileDialog.DeserializeBookmarks(strStream.str());
		docFile.close();
	}
#endif
}

Node* BluePrintUI::FindEntryPointNode()
{
    for (auto& node : m_Document->m_Blueprint.GetNodes())
    {
        if (node->GetTypeInfo().m_Type == NodeType::EntryPoint)
        {
            return node;
        }
    }

    return nullptr;
}

Node* BluePrintUI::FindExitPointNode()
{
    for (auto& node : m_Document->m_Blueprint.GetNodes())
    {
        if (node->GetTypeInfo().m_Type == NodeType::ExitPoint)
        {
            return node;
        }
    }

    return nullptr;
}

void BluePrintUI::CleanStateStorage()
{
    auto window = ImGui::GetCurrentWindowRead();
    if (window)
    {
        auto current_window = (*GImGui).CurrentWindow;
        auto storage = ImGui::GetStateStorage();
        if (storage && current_window)
        {
            storage->SetVoidPtr(ImGui::GetID("##node-context-menu-node"), nullptr);
            storage->SetVoidPtr(ImGui::GetID("##pin-context-menu-pin"), nullptr);
            storage->SetVoidPtr(ImGui::GetID("##link-context-menu-pin"), nullptr);
            storage->SetVoidPtr(ImGui::GetID("##setting-node"), nullptr);
            storage->SetVoidPtr(ImGui::GetID("##delete-node"), nullptr);
            storage->SetVoidPtr(ImGui::GetID("##create_node_pin"), nullptr);
        }
    }
}

bool BluePrintUI::Blueprint_IsValid()
{
    if (!m_Document)
        return false;
    if (!m_Document->m_Blueprint.IsOpened())
        return false;
    auto entryNode = FindEntryPointNode();
    auto exitNode = FindExitPointNode();
    if (!entryNode || !exitNode)
        return false;
    if (!entryNode->m_ID || !exitNode->m_ID)
        return false;
    return true;
}

bool BluePrintUI::File_Open(std::string path, string* error)
{
    if (File_IsOpen())
    {
        m_Document->Save();
        ed::ClearSelection();
        m_Document->m_Blueprint.Clear();
    }
    if (m_Document->Load(path) != BP_ERR_NONE)
    {
        if (error)
        {
            ImGuiTextBuffer buffer;
            buffer.appendf("Failed to load blueprint from file \"%" PRI_sv "\".", FMT_sv(path));
            *error = buffer.c_str();
        }
        else
            LOGE("Failed to load blueprint from file \"%" PRI_sv "\".", FMT_sv(path));
        return false;
    }

    LOGI("[File] Open \"%" PRI_sv "\"", FMT_sv(path));
    if (!m_isChildWindow)
    {
        auto mostRecentlyOpenFiles = ImGui::MostRecentlyUsedList("BluePrintOpenList");
        mostRecentlyOpenFiles.Add(path);
    }
    //m_Document->SetPath(path);
    m_Document->OnMakeCurrent();
    if (m_DebugOverlay) m_DebugOverlay->Init(&m_Document->m_Blueprint);
    return true;
}

bool BluePrintUI::File_Open()
{
    bool result = true;
    std::string filePathName;
    const ImGuiFileDialogFlags pflags = ImGuiFileDialogFlags_None | ImGuiFileDialogFlags_CaseInsensitiveExtention | ImGuiFileDialogFlags_Modal;
    const char *filters = "Blue print file (*.json *.bp){.json,.bp},.*";
    m_FileDialog.OpenDialog("##OpenFileDlgKey", ICON_IGFD_FOLDER_OPEN " Open File", filters, ".", 1, nullptr, m_BookMarkPath.empty() ? pflags : pflags | ImGuiFileDialogFlags_ShowBookmark);
    return result;
}

bool BluePrintUI::File_Import(std::string path, ImVec2 pos, string* error)
{
    if (m_Document->Import(path, pos) != BP_ERR_NONE)
    {
        if (error)
        {
            ImGuiTextBuffer buffer;
            buffer.appendf("Failed to import group from file \"%" PRI_sv "\".", FMT_sv(path));
            *error = buffer.c_str();
        }
        else
            LOGE("Failed to import group from file \"%" PRI_sv "\".", FMT_sv(path));
        return false;
    }

    LOGI("[File] Import group\"%" PRI_sv "\"", FMT_sv(path));
    return true;
}

bool BluePrintUI::File_Import()
{
    bool result = true;
    std::string filePathName;
    const ImGuiFileDialogFlags pflags = ImGuiFileDialogFlags_None | ImGuiFileDialogFlags_CaseInsensitiveExtention | ImGuiFileDialogFlags_Modal;
    const char *filters = "Group file (*.group *.gp){.group,.gp},.*";
    m_FileDialog.OpenDialog("##ImportGroupDlgKey", ICON_IGFD_FOLDER_OPEN " Open File", filters, ".", 1, &m_PopupMousePos, m_BookMarkPath.empty() ? pflags : pflags | ImGuiFileDialogFlags_ShowBookmark);
    return result;
}

bool BluePrintUI::File_New()
{
    File_Close();
    ed::SetCurrentEditor(m_Editor);
    ed::ClearSelection();
    m_Document->m_Blueprint.Clear();
    CleanStateStorage();
    ed::NavigateToOrigin();
    CreateNewDocument();
    m_Document->m_Name = "NONAMED";
    if (m_DebugOverlay) m_DebugOverlay->Init(&m_Document->m_Blueprint);
    return true;
}

bool BluePrintUI::File_New_Filter(imgui_json::value& bp, std::string name, std::string sfilter)
{
    ed::SetCurrentEditor(m_Editor);
    ed::ClearSelection();
    m_Document->m_Blueprint.Clear();
    CleanStateStorage();
    if (bp.is_object())
    {
        if (m_Document->Deserialize(bp, *m_Document) != BP_ERR_NONE || m_Document->m_Blueprint.GetNodes().size() == 0)
        {
            // TODO::Dicky if node load failed, may not CreateNewDocument
            CreateNewFilterDocument();
            m_Document->OnMakeCurrent();
            bp = m_Document->Serialize();
        }
        else
        {
            m_Document->OnMakeCurrent();
        }
    }
    else
    {
        CreateNewFilterDocument();
        m_Document->OnMakeCurrent();
        bp = m_Document->Serialize();
    }
    if (name.empty())
        m_Document->m_Name = "FilterBluePrint";
    else
        m_Document->m_Name = name;
    if (sfilter.empty())
        m_Document->m_CatalogFilter = "";
    else
        m_Document->m_CatalogFilter = sfilter;

    if (m_DebugOverlay) m_DebugOverlay->Init(&m_Document->m_Blueprint);
    return true;
}

bool BluePrintUI::File_New_Fusion(imgui_json::value& bp, std::string name, std::string sfilter)
{
    ed::SetCurrentEditor(m_Editor);
    ed::ClearSelection();
    m_Document->m_Blueprint.Clear();
    CleanStateStorage();
    if (bp.is_object())
    {
        if (m_Document->Deserialize(bp, *m_Document) != BP_ERR_NONE || m_Document->m_Blueprint.GetNodes().size() == 0)
        {
            // TODO::Dicky if node load failed, may not CreateNewDocument
            CreateNewFusionDocument();
            m_Document->OnMakeCurrent();
            bp = m_Document->Serialize();
        }
        else
        {
            m_Document->OnMakeCurrent();
        }
    }
    else
    {
        CreateNewFusionDocument();
        m_Document->OnMakeCurrent();
        bp = m_Document->Serialize();
    }
    if (name.empty())
        m_Document->m_Name = "FusionBluePrint";
    else
        m_Document->m_Name = name;

    if (sfilter.empty())
        m_Document->m_CatalogFilter = "";
    else
        m_Document->m_CatalogFilter = sfilter;
    
    if (m_DebugOverlay) m_DebugOverlay->Init(&m_Document->m_Blueprint);
    return true;
}

bool BluePrintUI::File_SaveAsEx(std::string path)
{
    if (!File_IsOpen())
        return true;
    if (!m_Document->Save(path))
    {
        LOGE("Failed to save blueprint to file \"%" PRI_sv "\".", FMT_sv(path));
        return false;
    }
    m_Document->m_IsModified = false;
    LOGI("[File] Save \"%" PRI_sv "\".", FMT_sv(path));
    return true;
}

bool BluePrintUI::File_SaveAs()
{
    const ImGuiFileDialogFlags pflags = ImGuiFileDialogFlags_ConfirmOverwrite | ImGuiFileDialogFlags_CaseInsensitiveExtention | ImGuiFileDialogFlags_Modal;
    const char *filters = "Blue print file (*.json *.bp){.json,.bp},.*";
    auto& io = ImGui::GetIO();
    auto viewport = ImGui::GetWindowViewport();
    ImVec2 maxSize = viewport->Size;
	ImVec2 minSize = maxSize * 0.5f;
    m_FileDialog.OpenDialog("##SaveFileDlgKey", ICON_IGFD_FOLDER_OPEN " Save File", filters, ".", 1, nullptr, m_BookMarkPath.empty() ? pflags : pflags |ImGuiFileDialogFlags_ShowBookmark);
    return true;
}

bool BluePrintUI::File_Save()
{
    if (!m_Document->m_Path.empty())
        return File_SaveAsEx(m_Document->m_Path);
    else
        return File_SaveAs();
}

bool BluePrintUI::File_Close()
{
    // TODO::Dicky Do we need close file?
    if (!File_IsOpen())
        return true;
    bool result = true;
    if (File_IsModified())
    {
        File_Save();
    }
    LOGI("[File] Close");
    return result;
}

bool BluePrintUI::File_Exit()
{
    // TODO::Dicky Do we need Exit
    LOGI("Quit");
    ReadyToQuit = true;
    return false;
}

bool BluePrintUI::Edit_Undo()
{
    bool ret = false;
    if (m_Document)
    {
        ret = m_Document->Undo();
        if (m_DebugOverlay) m_DebugOverlay->Init(&m_Document->m_Blueprint);
    }
    return ret;
}

bool BluePrintUI::Edit_Redo()
{
    return m_Document ? m_Document->Redo() : false;
}

bool BluePrintUI::Edit_Cut()
{
    m_ClipBoard.clear();
    auto selectedNodes = GetSelectedNodes(&m_Document->m_Blueprint);
    ed::ClearSelection();
    for (auto node : selectedNodes)
    {
        auto clip = ClipNode(node);
        m_ClipBoard.push_back(clip);
        LOGI("[Edit]: Cut Node %s", clip.m_Name.c_str());
        ed::DeleteNode(node->m_ID);
    }
    m_Document->m_IsModified = true;
    return selectedNodes.size() > 0;
}

bool BluePrintUI::Edit_Copy()
{
    m_ClipBoard.clear();
    auto nodes = GetSelectedNodes(&m_Document->m_Blueprint);
    for (auto node : nodes)
    {
        auto clip = ClipNode(node);
        m_ClipBoard.push_back(clip);
        LOGI("[Edit]: Copy Node %s", node->GetName().c_str());
    }
    return nodes.size();
}

bool BluePrintUI::Edit_Paste()
{
    ed::ClearSelection();
    for (auto clip : m_ClipBoard)
    {
        auto clone_node = m_Document->m_Blueprint.CreateNode(clip.m_NodeInfo.m_ID);
        
        ed::SetNodePosition(clone_node->m_ID, ImVec2(clip.m_Pos.x + 40, clip.m_Pos.y + 80));
        ed::SetNodeSize(clone_node->m_ID, clip.m_Size);
        ed::SetGroupSize(clone_node->m_ID, clip.m_GroupSize);
        ed::SelectNode(clone_node->m_ID, true);
        clone_node->SetName(clip.m_Name);
        LOGI("[Edit]: Paste Node %s", clip.m_Name.c_str());
    }
    return m_ClipBoard.size() > 0;
}

bool BluePrintUI::Edit_Duplicate()
{
    auto nodes = GetSelectedNodes(&m_Document->m_Blueprint);
    ed::ClearSelection();
    for (auto node : nodes)
    {
        auto nodeStart = ed::GetNodePosition(node->m_ID);
        auto nodeSize = ed::GetNodeSize(node->m_ID);
        auto groupSize = ed::GetGroupSize(node->m_ID);
        auto clone_node = m_Document->m_Blueprint.CloneNode(node);
        if (!clone_node)
            continue;
        ed::SetNodePosition(clone_node->m_ID, ImVec2(nodeStart.x + 40, nodeStart.y + 80));
        ed::SetNodeSize(clone_node->m_ID, nodeSize);
        ed::SetGroupSize(clone_node->m_ID, groupSize);
        ed::SelectNode(clone_node->m_ID, true);
        LOGI("[Edit]: Clone Node 0x%08" PRIX32, clone_node->m_ID);
    }
    return nodes.size() > 0;
}

bool BluePrintUI::Edit_Delete()
{
    auto selectedNodes = GetSelectedNodes(&m_Document->m_Blueprint);
    ed::ClearSelection();
    for (auto node : selectedNodes)
    {
        ed::DeleteNode(node->m_ID);
        LOGI("[Edit]: Delete Node 0x%08" PRIX32, node->m_ID);
    }
    m_Document->m_IsModified = true;
    return selectedNodes.size() > 0;
}

bool BluePrintUI::Edit_Unlink()
{
    auto selectedLinks = GetSelectedLinks(&m_Document->m_Blueprint);
    ed::ClearSelection();
    for (auto selectedLink : selectedLinks)
    {
        ed::DeleteLink(selectedLink->m_ID);
        LOGI("[Edit]: Remove Link 0x%08" PRIX32, selectedLink->m_ID);
    }
    m_Document->m_IsModified = true;
    return selectedLinks.size() > 0;
}

bool BluePrintUI::Edit_Setting()
{
    return false; // TODO::Dicky
}

bool BluePrintUI::Edit_Insert(ID_TYPE id)
{
    if (!Blueprint_IsValid())
        return false;
    ed::SetCurrentEditor(m_Editor);
    ed::ClearSelection();
    auto new_node = m_Document->m_Blueprint.CreateNode(id);
    if (!new_node)
        return false;
    ed::SetNodePosition(new_node->m_ID, ImVec2(40, 80));
    ed::SelectNode(new_node->m_ID, true);
    return true;
}

bool BluePrintUI::View_ShowFlow()
{
    if (!m_Document)
        return false;

    m_Document->m_Blueprint.ShowFlow();
    
    return true;
}

bool BluePrintUI::View_ShowMeters()
{
    if (!m_Document)
        return false;

    ed::TriggerShowMeters();
    return true;
}

bool BluePrintUI::View_ZoomToContent()
{
    if (m_Document)
    {
        ed::NavigateToContent();
        return true;
    }
    return false;
}

bool BluePrintUI::View_ZoomToSelection()
{
    if (m_Document)
    {
        ed::NavigateToSelection(true);
        return true;
    }
    return false;
}

bool BluePrintUI::View_NavigateBackward()
{
    return false; // TODO::Dicky
}

bool BluePrintUI::View_NavigateForward()
{
    return false; // TODO::Dicky
}

bool BluePrintUI::Blueprint_Stop()
{
    if (!m_Document)
        return false;
    m_Document->m_Blueprint.Stop();
    return true;
}

bool BluePrintUI::Blueprint_Run()
{
    if (!m_Document)
        return false;
    auto entryNode = FindEntryPointNode();
    auto result = m_Document->m_Blueprint.Execute(*entryNode);
    if (result == StepResult::Error)
    {
        LOGI("Execution: Failed at step %" PRIu32, m_Document->m_Blueprint.StepCount());
        return false;
    }
    else if (result == StepResult::Done)
    {
        LOGI("Execution: Running");
    }
    return true;
}

bool BluePrintUI::Blueprint_SetFilter(const std::string name, const PinValue& value)
{
    if (!Blueprint_IsValid())
        return false;
    auto entry_node = FindEntryPointNode();
    if (!entry_node)
        return false;
    FilterEntryPointNode * entryNode = (FilterEntryPointNode *)entry_node;
    FloatPin * pin = (FloatPin * )entryNode->FindPin(name);
    if (pin)
    {
        return pin->SetValue(value);
    }
    return false;
}

bool BluePrintUI::Blueprint_RunFilter(ImGui::ImMat& input, ImGui::ImMat& output)
{
    if (!Blueprint_IsValid())
        return false;
    auto entry_node = FindEntryPointNode();
    auto exit_node = FindExitPointNode();
    if (!entry_node || !exit_node)
        return false;
    
    FilterEntryPointNode * entryNode = (FilterEntryPointNode *)entry_node;
    MatExitPointNode * exitNode = (MatExitPointNode *)exit_node;
    entryNode->m_MatOut.SetValue(input);
    auto result = m_Document->m_Blueprint.Run(*entryNode);
    if (result == StepResult::Error)
    {
        LOGI("Execution: Failed at step %" PRIu32, m_Document->m_Blueprint.StepCount());
        return false;
    }
    else if (result == StepResult::Done)
    {
        LOGI("Execution: Running");
    }
    auto output_val = exitNode->m_MatIn.GetValue();
    output = output_val.As<ImGui::ImMat>();
    return true;
}

bool BluePrintUI::Blueprint_SetFusion(const std::string name, const PinValue& value)
{
    if (!Blueprint_IsValid())
        return false;
    auto entry_node = FindEntryPointNode();
    if (!entry_node)
        return false;
    FusionEntryPointNode * entryNode = (FusionEntryPointNode *)entry_node;
    FloatPin * pin = (FloatPin * )entryNode->FindPin(name);
    if (pin)
    {
        return pin->SetValue(value);
    }
    return false;
}

bool BluePrintUI::Blueprint_RunFusion(ImGui::ImMat& input_first, ImGui::ImMat& input_second, ImGui::ImMat& output, int64_t current, int64_t duration)
{
    if (!Blueprint_IsValid())
        return false;
    auto entry_node = FindEntryPointNode();
    auto exit_node = FindExitPointNode();
    if (!entry_node || !exit_node)
        return false;
    
    FusionEntryPointNode * entryNode = (FusionEntryPointNode *)entry_node;
    MatExitPointNode * exitNode = (MatExitPointNode *)exit_node;
    entryNode->m_MatOutFirst.SetValue(input_first);
    entryNode->m_MatOutSecond.SetValue(input_second);
    //entryNode->m_FusionDuration.SetValue(duration);
    //entryNode->m_FusionTimeStamp.SetValue(current);
    auto result = m_Document->m_Blueprint.Run(*entryNode);
    if (result == StepResult::Error)
    {
        LOGI("Execution: Failed at step %" PRIu32, m_Document->m_Blueprint.StepCount());
        return false;
    }
    else if (result == StepResult::Done)
    {
        LOGI("Execution: Running");
    }
    auto output_val = exitNode->m_MatIn.GetValue();
    output = output_val.As<ImGui::ImMat>();
    return true;
}

bool BluePrintUI::Blueprint_Pause()
{
    if (!m_Document)
        return false;
    auto result = m_Document->m_Blueprint.Pause();
    LOGI("Execution: Paused at step %" PRIu32, m_Document->m_Blueprint.StepCount());
    return true;
}

bool BluePrintUI::Blueprint_Next()
{
    if (!m_Document)
        return false;
    auto result = m_Document->m_Blueprint.Next();

    ed::PushStyleVar(ed::StyleVar_FlowMarkerDistance, 30.0f);
    ed::PushStyleVar(ed::StyleVar_FlowDuration, 1.0f);
    m_Document->m_Blueprint.ShowFlow();
    ed::PopStyleVar(2);

    return true;
}

bool BluePrintUI::Blueprint_Current()
{
    if (!m_Document)
        return false;
    auto result = m_Document->m_Blueprint.Current();

    ed::PushStyleVar(ed::StyleVar_FlowMarkerDistance, 30.0f);
    ed::PushStyleVar(ed::StyleVar_FlowDuration, 1.0f);
    m_Document->m_Blueprint.ShowFlow();
    ed::PopStyleVar(2);

    return true;
}

bool BluePrintUI::Blueprint_BreakPoint()
{
    if (!m_Document)
        return false;
    auto selectedNodes = GetSelectedNodes(&m_Document->m_Blueprint);
    for (auto node : selectedNodes)
    {
        if (node->m_BreakPoint)
        {
            node->SetBreakPoint(false);
            LOGI("Execution: delete breakpoint 0x%08" PRIX32, node->m_ID);
        }
        else
        {
            node->SetBreakPoint(true);
            LOGI("Execution: Set breakpoint 0x%08" PRIX32, node->m_ID);
        }
    }
    return true;
}

bool BluePrintUI::File_Export(Node * group_node)
{
    const ImGuiFileDialogFlags pflags = ImGuiFileDialogFlags_ConfirmOverwrite | ImGuiFileDialogFlags_CaseInsensitiveExtention | ImGuiFileDialogFlags_Modal;
    const char *filters = "Group file (*.group *.gp){.group,.gp},.*";
    auto& io = ImGui::GetIO();
    auto viewport = ImGui::GetWindowViewport();
    ImVec2 maxSize = viewport->Size;
	ImVec2 minSize = maxSize * 0.5f;
    m_FileDialog.OpenDialog("##SaveGroupDlgKey", ICON_IGFD_FOLDER_OPEN " Save Group File", filters, ".", 1, group_node, m_BookMarkPath.empty() ? pflags : pflags | ImGuiFileDialogFlags_ShowBookmark);
    return true;
}

void BluePrintUI::UpdateActions()
{
    //auto mostRecentlyOpenFiles = ImGui::MostRecentlyUsedList("BluePrintOpenList");
    auto hasDocument = File_IsOpen();
    auto hasUndo     = hasDocument && !m_Document->m_Undo.empty();
    auto hasRedo     = hasDocument && !m_Document->m_Redo.empty();
    auto isModified  = hasDocument && File_IsModified();
    auto entryNode = FindEntryPointNode();
    auto exitNode = FindExitPointNode();
    bool hasBlueprint = true;
    bool hasEntryPoint = (entryNode != nullptr);
    bool hasExitPoint = (exitNode != nullptr);
    bool isExecuting   = m_Document->m_Blueprint.CurrentNode() != nullptr;
    bool hasSelectedNode   = GetSelectedNodes(&m_Document->m_Blueprint).size() > 0;
    bool hasSelectedLink   = GetSelectedLinks(&m_Document->m_Blueprint).size() > 0;
    bool hasClipBoardNodes = m_ClipBoard.size() > 0;
    bool isThreadExecuting = m_Document->m_Blueprint.IsExecuting();
    bool isThreadPaused = m_Document->m_Blueprint.IsPaused();
    bool isEditable = true;
    bool hasExportedLink = false;
    if (hasSelectedLink)
    {
        auto links = GetSelectedLinks(&m_Document->m_Blueprint);
        for (auto pin : links)
        {
            if (pin->IsLinkedExportedPin())
            {
                hasExportedLink = true;
                break;
            }
        }
    }

    auto select_nodes = GetSelectedNodes(&m_Document->m_Blueprint);
    for (auto node : select_nodes)
    {
        if (node->GetTypeInfo().m_Type == NodeType::EntryPoint)
            isEditable = false;
        if (node->GetTypeInfo().m_Type == NodeType::ExitPoint)
            isEditable = false;
    }

    m_File_Open.SetEnabled(!isThreadExecuting);
    m_File_New.SetEnabled(!isThreadExecuting);
    m_File_Close.SetEnabled(hasDocument && !isThreadExecuting);
    m_File_SaveAs.SetEnabled(hasDocument && !isThreadExecuting);
    m_File_Save.SetEnabled(hasDocument && !isThreadExecuting);
    m_Edit_Undo.SetEnabled(hasUndo && (!isThreadExecuting || isThreadPaused));
    m_Edit_Redo.SetEnabled(hasRedo && (!isThreadExecuting || isThreadPaused));
    m_Edit_Cut.SetEnabled(hasDocument && hasSelectedNode && (!isThreadExecuting || isThreadPaused) && isEditable);
    m_Edit_Copy.SetEnabled(hasDocument && hasSelectedNode && (!isThreadExecuting || isThreadPaused) && isEditable);
    m_Edit_Paste.SetEnabled(hasDocument && hasClipBoardNodes && (!isThreadExecuting || isThreadPaused) && isEditable);
    m_Edit_Duplicate.SetEnabled(hasDocument && hasSelectedNode && (!isThreadExecuting || isThreadPaused) && isEditable);
    m_Edit_Delete.SetEnabled(hasDocument && hasSelectedNode && (!isThreadExecuting || isThreadPaused) && isEditable);
    m_Edit_Unlink.SetEnabled(hasDocument && hasSelectedLink && !hasExportedLink && (!isThreadExecuting || isThreadPaused));
    m_Edit_Setting.SetEnabled(hasDocument && (!isThreadExecuting || isThreadPaused));
    m_View_NavigateBackward.SetEnabled(hasDocument && false);
    m_View_NavigateForward.SetEnabled(hasDocument && false);
    m_View_ShowFlow.SetEnabled(hasDocument && (!isThreadExecuting || isThreadPaused));
    m_View_ZoomToContent.SetEnabled(hasBlueprint);
    m_View_ZoomToSelection.SetEnabled(hasBlueprint);
    m_Blueprint_Stop.SetEnabled(hasBlueprint && (isExecuting || isThreadExecuting));
    m_Blueprint_Run.SetEnabled(hasBlueprint && hasEntryPoint && (!isThreadExecuting || isThreadPaused));
    m_Blueprint_Pause.SetEnabled(hasBlueprint && hasEntryPoint && isThreadExecuting && !isThreadPaused);
#if defined(__EMSCRIPTEN__)
    m_Blueprint_Next.SetEnabled(hasBlueprint && hasEntryPoint && isExecuting);
#else
    m_Blueprint_Next.SetEnabled(hasBlueprint && hasEntryPoint && isThreadExecuting && isThreadPaused);
#endif
    m_Blueprint_Current.SetEnabled(hasBlueprint && hasEntryPoint && isThreadExecuting && isThreadPaused);
}

void BluePrintUI::ShowStyleEditor(bool* show)
{
    if (!ImGui::Begin("Edit Style", show))
    {
        ImGui::End();
        return;
    }
    float paneWidth = 600;
    auto& editorStyle = ed::GetStyle();
    ImGui::BeginHorizontal("Style buttons", ImVec2(paneWidth, 0), 1.0f);
    ImGui::TextUnformatted("Values");
    ImGui::Spring();
    if (ImGui::Button("Reset to defaults"))
        editorStyle = ed::Style();
    ImGui::EndHorizontal();
    ImGui::Spacing();
    ImGui::DragFloat4("Node Padding", &editorStyle.NodePadding.x, 0.1f, 0.0f, 40.0f);
    ImGui::DragFloat("Node Rounding", &editorStyle.NodeRounding, 0.1f, 0.0f, 40.0f);
    ImGui::DragFloat("Node Border Width", &editorStyle.NodeBorderWidth, 0.1f, 0.0f, 15.0f);
    ImGui::DragFloat("Hovered Node Border Width", &editorStyle.HoveredNodeBorderWidth, 0.1f, 0.0f, 15.0f);
    ImGui::DragFloat("Selected Node Border Width", &editorStyle.SelectedNodeBorderWidth, 0.1f, 0.0f, 15.0f);
    ImGui::DragFloat("Pin Rounding", &editorStyle.PinRounding, 0.1f, 0.0f, 40.0f);
    ImGui::DragFloat("Pin Border Width", &editorStyle.PinBorderWidth, 0.1f, 0.0f, 15.0f);
    ImGui::DragFloat("Link Strength", &editorStyle.LinkStrength, 1.0f, 0.0f, 500.0f);
    //ImVec2  SourceDirection;
    //ImVec2  TargetDirection;
    ImGui::DragFloat("Scroll Duration", &editorStyle.ScrollDuration, 0.001f, 0.0f, 2.0f);
    ImGui::DragFloat("Flow Marker Distance", &editorStyle.FlowMarkerDistance, 1.0f, 1.0f, 200.0f);
    ImGui::DragFloat("Flow Speed", &editorStyle.FlowSpeed, 1.0f, 1.0f, 2000.0f);
    ImGui::DragFloat("Flow Duration", &editorStyle.FlowDuration, 0.001f, 0.0f, 5.0f);
    //ImVec2  PivotAlignment;
    //ImVec2  PivotSize;
    //ImVec2  PivotScale;
    //float   PinCorners;
    //float   PinRadius;
    //float   PinArrowSize;
    //float   PinArrowWidth;
    ImGui::DragFloat("Group Rounding", &editorStyle.GroupRounding, 0.1f, 0.0f, 40.0f);
    ImGui::DragFloat("Group Border Width", &editorStyle.GroupBorderWidth, 0.1f, 0.0f, 15.0f);
    ImGui::Separator();
    static ImGuiColorEditFlags edit_mode = ImGuiColorEditFlags_DisplayRGB;
    ImGui::BeginHorizontal("Color Mode", ImVec2(paneWidth, 0), 1.0f);
    ImGui::TextUnformatted("Filter Colors");
    ImGui::Spring();
    ImGui::RadioButton("RGB", &edit_mode, ImGuiColorEditFlags_DisplayRGB);
    ImGui::Spring(0);
    ImGui::RadioButton("HSV", &edit_mode, ImGuiColorEditFlags_DisplayHSV);
    ImGui::Spring(0);
    ImGui::RadioButton("HEX", &edit_mode, ImGuiColorEditFlags_DisplayHex);
    ImGui::EndHorizontal();
    static ImGuiTextFilter filter;
    filter.Draw("", paneWidth);
    ImGui::Spacing();
    for (int i = 0; i < ed::StyleColor_Count; ++i)
    {
        auto name = ed::GetStyleColorName((ed::StyleColor)i);
        if (!filter.PassFilter(name))
            continue;
        ImGui::ColorEdit4(name, &editorStyle.Colors[i].x, edit_mode);
    }
    ImGui::End();
}

void BluePrintUI::ShowShortToolbar(bool vertical, bool* show)
{
    auto& io = ImGui::GetIO();
    ImVec2 window_pos = ImGui::GetWindowPos();
    ImVec2 window_size = ImGui::GetWindowSize();
    ImGuiWindowFlags window_flags = ImGuiWindowFlags_NoDecoration | ImGuiWindowFlags_AlwaysAutoResize | ImGuiWindowFlags_NoFocusOnAppearing | ImGuiWindowFlags_NoNav | ImGuiWindowFlags_NoMove | ImGuiWindowFlags_NoSavedSettings;
    if (io.ConfigFlags & ImGuiConfigFlags_ViewportsEnable)
    {
        const ImGuiViewport* viewport = ImGui::GetWindowViewport();
        window_flags |= ImGuiWindowFlags_NoDocking;
        io.ConfigViewportsNoDecoration = true;
        ImGui::SetNextWindowViewport(viewport->ID);
    }
    ImGui::SetNextWindowBgAlpha(0.35f); // Transparent background
    ImGui::PushStyleColor(ImGuiCol_Button, m_StyleColors[BluePrintStyleColor_ToolButton]);
    ImGui::PushStyleColor(ImGuiCol_ButtonHovered, m_StyleColors[BluePrintStyleColor_ToolButtonHovered]);
    ImGui::PushStyleColor(ImGuiCol_ButtonActive, m_StyleColors[BluePrintStyleColor_ToolButtonActive]);
    ImGui::PushStyleColor(ImGuiCol_Separator, ImVec4(1.0, 1.0, 1.0, 0.8));
    ImGui::PushStyleVar(ImGuiStyleVar_TexGlyphShadowOffset, ImVec2(2.0, 2.0));
    ImGui::SetNextWindowPos(window_pos + ImVec2(vertical ? window_size.x - 48 : window_size.x - 432, 8));
    if (ImGui::Begin("##embedded_toolbar", show, window_flags))
    {
        if (io.ConfigFlags & ImGuiConfigFlags_ViewportsEnable)
        {
            auto viewport = ImGui::GetWindowViewport();
            viewport->Flags |= ImGuiViewportFlags_TopMost;
        }
        auto toolbarAction = [](Action& action)
        {
            ImGui::ScopedDisableItem disableAction(!action.IsEnabled());
#if IMGUI_ICONS
            string title = action.GetIcon() + "##toolbar";
#else
            string title = action.GetName() + "##toolbar";
#endif
            if (ImGui::Button(title.c_str()))
            {
                action.Execute();
            }
        };
        toolbarAction(m_View_ShowFlow); ImGui::ShowTooltipOnHover("%s", m_View_ShowFlow.GetName().c_str());
        if (!vertical) ImGui::SameLine();
        toolbarAction(m_View_ZoomToContent); ImGui::ShowTooltipOnHover("%s", m_View_ZoomToContent.GetName().c_str());
        if (!vertical) ImGui::SameLine();
        toolbarAction(m_View_ZoomToSelection); ImGui::ShowTooltipOnHover("%s", m_View_ZoomToSelection.GetName().c_str());
        if (!vertical) { ImGui::SameLine(); ImGui::SeparatorEx(ImGuiSeparatorFlags_Vertical); ImGui::SameLine(); }
        else ImGui::SeparatorEx(ImGuiSeparatorFlags_Horizontal);
        toolbarAction(m_Edit_Copy); ImGui::ShowTooltipOnHover("%s", m_Edit_Copy.GetName().c_str());
        if (!vertical) ImGui::SameLine();
        toolbarAction(m_Edit_Paste); ImGui::ShowTooltipOnHover("%s", m_Edit_Paste.GetName().c_str());
        if (!vertical) ImGui::SameLine();
        toolbarAction(m_Edit_Cut); ImGui::ShowTooltipOnHover("%s", m_Edit_Cut.GetName().c_str());
        if (!vertical) ImGui::SameLine();
        toolbarAction(m_Edit_Duplicate); ImGui::ShowTooltipOnHover("%s", m_Edit_Duplicate.GetName().c_str());
        if (!vertical) ImGui::SameLine();
        toolbarAction(m_Edit_Delete); ImGui::ShowTooltipOnHover("%s", m_Edit_Delete.GetName().c_str());
        if (!vertical) ImGui::SameLine();
        toolbarAction(m_Edit_Unlink); ImGui::ShowTooltipOnHover("%s", m_Edit_Unlink.GetName().c_str());
        if (!vertical) { ImGui::SameLine(); ImGui::SeparatorEx(ImGuiSeparatorFlags_Vertical); ImGui::SameLine(); }
        else ImGui::SeparatorEx(ImGuiSeparatorFlags_Horizontal);
        toolbarAction(m_Edit_Undo); ImGui::ShowTooltipOnHover("%s", m_Edit_Undo.GetName().c_str());
        if (!vertical) ImGui::SameLine();
        toolbarAction(m_Edit_Redo); ImGui::ShowTooltipOnHover("%s", m_Edit_Redo.GetName().c_str());
        // Show Info tooltip
        if (!vertical) { ImGui::SameLine(); ImGui::SeparatorEx(ImGuiSeparatorFlags_Vertical); ImGui::SameLine(); }
        else ImGui::SeparatorEx(ImGuiSeparatorFlags_Horizontal);
        string info_button_title = string(ICON_MD_INFO_OUTLINE) + "##info_tooltips";
        ImGui::CheckButton(info_button_title.c_str(), &m_isShowInfoTooltips);
        ImGui::ShowTooltipOnHover("Show Info in tooltips");
        // Show Thumbnails
        //if (!vertical) { ImGui::SameLine(); ImGui::SeparatorEx(ImGuiSeparatorFlags_Vertical); ImGui::SameLine(); }
        //else ImGui::SeparatorEx(ImGuiSeparatorFlags_Horizontal);
        //string thumbnail_button_title = string(ICON_THUMBNAIL) + "##thumbnails";
        //ImGui::CheckButton(thumbnail_button_title.c_str(), &m_isShowThumbnails);
        //ImGui::ShowTooltipOnHover("Show Thumbnails");
    }
    ImGui::End();
    ImGui::PopStyleVar(1);
    ImGui::PopStyleColor(4);
    if (io.ConfigFlags & ImGuiConfigFlags_ViewportsEnable)
    {
        io.ConfigViewportsNoDecoration = false;
    }
}

void BluePrintUI::ShowToolbar(bool* show)
{
    auto& io = ImGui::GetIO();
    ImVec2 window_pos = ImGui::GetWindowPos();
    ImVec2 window_size = ImGui::GetWindowSize();
    ImGuiWindowFlags window_flags = ImGuiWindowFlags_NoDecoration | ImGuiWindowFlags_AlwaysAutoResize | ImGuiWindowFlags_NoFocusOnAppearing | ImGuiWindowFlags_NoNav;
    if (io.ConfigFlags & ImGuiConfigFlags_ViewportsEnable)
    {
        const ImGuiViewport* viewport = ImGui::GetWindowViewport();
        window_flags |= ImGuiWindowFlags_NoDocking;
        io.ConfigViewportsNoDecoration = true;
        ImGui::SetNextWindowViewport(viewport->ID);
    }
    ImGui::SetNextWindowBgAlpha(0.35f); // Transparent background
    ImGui::PushStyleColor(ImGuiCol_Button, m_StyleColors[BluePrintStyleColor_ToolButton]);
    ImGui::PushStyleColor(ImGuiCol_ButtonHovered, m_StyleColors[BluePrintStyleColor_ToolButtonHovered]);
    ImGui::PushStyleColor(ImGuiCol_ButtonActive, m_StyleColors[BluePrintStyleColor_ToolButtonActive]);
    ImGui::PushStyleVar(ImGuiStyleVar_TexGlyphShadowOffset, ImVec2(2.0, 2.0));
    if (ImGui::Begin("##floating_toolbar", show, window_flags))
    {
        if (io.ConfigFlags & ImGuiConfigFlags_ViewportsEnable)
        {
            auto viewport = ImGui::GetWindowViewport();
            viewport->Flags |= ImGuiViewportFlags_TopMost;
        }
        auto toolbarAction = [](Action& action)
        {
            ImGui::ScopedDisableItem disableAction(!action.IsEnabled());
#if IMGUI_ICONS
            string title = action.GetIcon() + "##toolbar";
#else
            string title = action.GetName() + "##toolbar";
#endif
            if (ImGui::Button(title.c_str()))
            {
                action.Execute();
            }
        };

        ImGui::Dummy(ImVec2(20, 0));
        ImGui::SameLine();
        toolbarAction(m_File_Open); ImGui::ShowTooltipOnHover("%s", m_File_Open.GetName().c_str());
        ImGui::SameLine();
        toolbarAction(m_File_New); ImGui::ShowTooltipOnHover("%s", m_File_New.GetName().c_str());
        ImGui::SameLine();
        toolbarAction(m_File_Save); ImGui::ShowTooltipOnHover("%s", m_File_Save.GetName().c_str());
        ImGui::SameLine();
        toolbarAction(m_File_SaveAs); ImGui::ShowTooltipOnHover("%s", m_File_SaveAs.GetName().c_str());
        ImGui::SameLine();
        ImGui::SeparatorEx(ImGuiSeparatorFlags_Vertical);
        ImGui::SameLine();
        ImGui::SeparatorEx(ImGuiSeparatorFlags_Vertical);
        ImGui::SameLine();
        toolbarAction(m_Edit_Undo); ImGui::ShowTooltipOnHover("%s", m_Edit_Undo.GetName().c_str());
        ImGui::SameLine();
        toolbarAction(m_Edit_Redo); ImGui::ShowTooltipOnHover("%s", m_Edit_Redo.GetName().c_str());
        ImGui::SameLine();
        toolbarAction(m_Edit_Copy); ImGui::ShowTooltipOnHover("%s", m_Edit_Copy.GetName().c_str());
        ImGui::SameLine();
        toolbarAction(m_Edit_Paste); ImGui::ShowTooltipOnHover("%s", m_Edit_Paste.GetName().c_str());
        ImGui::SameLine();
        toolbarAction(m_Edit_Cut); ImGui::ShowTooltipOnHover("%s", m_Edit_Cut.GetName().c_str());
        ImGui::SameLine();
        toolbarAction(m_Edit_Duplicate); ImGui::ShowTooltipOnHover("%s", m_Edit_Duplicate.GetName().c_str());
        ImGui::SameLine();
        toolbarAction(m_Edit_Delete); ImGui::ShowTooltipOnHover("%s", m_Edit_Delete.GetName().c_str());
        ImGui::SameLine();
        toolbarAction(m_Edit_Unlink); ImGui::ShowTooltipOnHover("%s", m_Edit_Unlink.GetName().c_str());
        ImGui::SameLine();
        ImGui::SeparatorEx(ImGuiSeparatorFlags_Vertical);
        ImGui::SameLine();
        ImGui::SeparatorEx(ImGuiSeparatorFlags_Vertical);
        ImGui::SameLine();
        toolbarAction(m_View_ShowFlow); ImGui::ShowTooltipOnHover("%s", m_View_ShowFlow.GetName().c_str());
        ImGui::SameLine();
        toolbarAction(m_View_ZoomToContent); ImGui::ShowTooltipOnHover("%s", m_View_ZoomToContent.GetName().c_str());
        ImGui::SameLine();
        toolbarAction(m_View_ZoomToSelection); ImGui::ShowTooltipOnHover("%s", m_View_ZoomToSelection.GetName().c_str());
        ImGui::SameLine();
        ImGui::SeparatorEx(ImGuiSeparatorFlags_Vertical);
        ImGui::SameLine();
        ImGui::SeparatorEx(ImGuiSeparatorFlags_Vertical);
        ImGui::SameLine();
        toolbarAction(m_Blueprint_Run); ImGui::ShowTooltipOnHover("%s", m_Blueprint_Run.GetName().c_str());
        ImGui::SameLine();
        toolbarAction(m_Blueprint_Pause); ImGui::ShowTooltipOnHover("%s", m_Blueprint_Pause.GetName().c_str());
        ImGui::SameLine();
        toolbarAction(m_Blueprint_Next); ImGui::ShowTooltipOnHover("%s", m_Blueprint_Next.GetName().c_str());
        ImGui::SameLine();
        toolbarAction(m_Blueprint_Current); ImGui::ShowTooltipOnHover("%s", m_Blueprint_Current.GetName().c_str());
        ImGui::SameLine();
        toolbarAction(m_Blueprint_Stop); ImGui::ShowTooltipOnHover("%s", m_Blueprint_Stop.GetName().c_str());
        ImGui::SameLine();
        ImGui::SeparatorEx(ImGuiSeparatorFlags_Vertical);
        ImGui::SameLine();
        string info_button_title = string(ICON_MD_INFO_OUTLINE) + "##info_tooltips";
        ImGui::CheckButton(info_button_title.c_str(), &m_isShowInfoTooltips);
        ImGui::ShowTooltipOnHover("Show Info in tooltips");
        ImGui::SameLine();
        string thumbnail_button_title = string(ICON_THUMBNAIL) + "##thumbnails";
        ImGui::CheckButton(thumbnail_button_title.c_str(), &m_isShowThumbnails);
        ImGui::ShowTooltipOnHover("Show Thumbnails");
        ImGui::SameLine();
        ImGui::SeparatorEx(ImGuiSeparatorFlags_Vertical);
        ImGui::SameLine();
        ImGui::SeparatorEx(ImGuiSeparatorFlags_Vertical);
        ImGui::SameLine();
        ImGui::Text("%d(%s)", m_Document->m_Blueprint.StepCount(), StepResultToString(m_Document->m_Blueprint.LastStepResult()));
        ImGui::SameLine();
        ImGui::Text("%.3fms/%.1fFPS", ImGui::GetIO().DeltaTime * 1000.f, ImGui::GetIO().Framerate);
        ImGui::SameLine();
        ImGui::Dummy(ImVec2(20, 0));
    }
    ImGui::End();
    ImGui::PopStyleVar(1);
    ImGui::PopStyleColor(3);
    if (io.ConfigFlags & ImGuiConfigFlags_ViewportsEnable)
    {
        io.ConfigViewportsNoDecoration = false;
    }
}

void BluePrintUI::Thumbnails(float view_expand, ImVec2 size, ImVec2 pos)
{
    auto& io = ImGui::GetIO();
    float zoom = ed::GetCurrentZoom();
    auto screen_size = (size.x == 0 || size.y == 0) ? ed::GetScreenSize() : size;
    auto screen_pos = (pos.x < 0 || pos.y < 0) ? screen_size - screen_size * m_ThumbnailScale : pos;
    auto view_rect = ed::GetViewRect();
    auto view_size = view_rect.GetSize();
    auto view_center = view_rect.GetCenter();
    if (view_expand < 1.f) view_expand = 1.0f;
    float view_scale = 1.f / view_expand;
    ImRect screen_rect(ImVec2(view_center.x - view_size.x * view_expand / 2.f, view_center.y - view_size.y * view_expand / 2.f), 
                        ImVec2(view_center.x + view_size.x * view_expand / 2.f, view_center.y + view_size.y * view_expand / 2.f));

    ImGuiWindowFlags window_flags = ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoDecoration | ImGuiWindowFlags_NoSavedSettings | ImGuiWindowFlags_NoNav | ImGuiWindowFlags_NoFocusOnAppearing | ImGuiWindowFlags_NoInputs;
    if (io.ConfigFlags & ImGuiConfigFlags_ViewportsEnable)
    {
        const ImGuiViewport* viewport = ImGui::GetWindowViewport();
        window_flags |= ImGuiWindowFlags_NoDocking;
        io.ConfigViewportsNoDecoration = true;
        ImGui::SetNextWindowViewport(viewport->ID);
    }
    float window_alpha = 0.5f;
    if (m_ThumbnailShowCount > 0)
    {
        if (m_isShowThumbnails)
            m_ThumbnailShowCount = 0;
        else if (m_ThumbnailShowCount <= THUMBNAIL_HIDDEN)
            window_alpha *= (float)m_ThumbnailShowCount / (float)THUMBNAIL_HIDDEN;
    }
    ImGui::SetNextWindowBgAlpha(window_alpha);
    ImGui::SetNextWindowPos(screen_pos);
    ImGui::SetNextWindowSize(screen_size * m_ThumbnailScale);
    if (ImGui::Begin("##floating_thumbnails", nullptr, window_flags))
    {
        auto cursorPos = ImGui::GetCursorScreenPos();
        auto window = ImGui::GetCurrentWindow();
        auto drawList  = ImGui::GetWindowDrawList();
        auto view_area_pos = (view_rect.Min - screen_rect.Min) * m_ThumbnailScale * view_scale / zoom;
        auto view_area_size = view_size * m_ThumbnailScale * view_scale / zoom;
        drawList->AddRect(cursorPos + view_area_pos, cursorPos + view_area_pos + view_area_size, ImGui::GetColorU32(ImGuiCol_Border, window_alpha));
        for (auto& node : m_Document->m_Blueprint.GetNodes())
        {
            auto node_pos = (ed::GetNodePosition(node->m_ID) - screen_rect.Min) * m_ThumbnailScale * view_scale / zoom;
            auto node_size = ed::GetNodeSize(node->m_ID) * m_ThumbnailScale * view_scale / zoom;
            drawList->AddRectFilled(cursorPos + node_pos, cursorPos + node_pos + node_size, ImGui::GetColorU32(ImGuiCol_Border, window_alpha));
        }
    }
    ImGui::End();
    m_ThumbnailShowCount --;
    if (m_ThumbnailShowCount <= 0) m_ThumbnailShowCount = 0;
}
} // namespace BluePrint
