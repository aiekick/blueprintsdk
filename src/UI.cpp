#include <UI.h>
#include <BuildInNodes.h> // Which is generated by cmake
#include <imgui_node_editor_internal.h>
#include <iomanip>

#define DEBUG_NODE_DRAWING  0
#define DEBUG_GROUP_NODE    0
extern std::mutex g_Mutex;

inline string to_lower(string s) 
{        
    for(char &c : s)
        c = tolower(c);
    return s;
}

const string titlebar_icons[] = {ICON_NODE_COPY, ICON_NODE_DELETE, ICON_NODE_SETTING, ICON_SAVE_BLUEPRINT};
                                //{"c", "d", "s", "S"};

namespace BluePrint
{

BluePrintStyle BPStyleFromName(string name)
{
    if (name.compare("Light") == 0)
        return BluePrintStyle::BP_Style_BluePrint;
    else if (name.compare("Dark") == 0)
        return BluePrintStyle::BP_Style_Dark;
    else if (name.compare("Mono") == 0)
        return BluePrintStyle::BP_Style_Mono;
    else if (name.compare("Custom") == 0)
        return BluePrintStyle::BP_Style_Custom;
    else
        return BluePrintStyle::BP_Style_BluePrint;
}

string BPStyleToString(BluePrintStyle style)
{
    switch (style)
    {
        default:                                return "Light";
        case BluePrintStyle::BP_Style_BluePrint:return "Light";
        case BluePrintStyle::BP_Style_Dark:     return "Dark";
        case BluePrintStyle::BP_Style_Mono:     return "Mono";
        case BluePrintStyle::BP_Style_Custom:   return "Custom";
    }
}
// ---------------------------
// ------[ ContextMenu ]------
// ---------------------------
void ContextMenu::Open(void)
{
    ImGui::OpenPopup("##context-menu");
}

void ContextMenu::Show(BluePrintUI& UI)
{
    if (!ImGui::IsPopupOpen("##context-menu"))
        return;

    //auto blueprint = &UI.m_Document->m_Blueprint;
    auto menuAction = [](Action& action)
    {
#if IMGUI_ICONS
        string ItemTitle = action.GetIcon() + " " + action.GetName();
#else
        string ItemTitle = action.GetName();
#endif
        if (ImGui::MenuItem(ItemTitle.c_str(), nullptr, nullptr, action.IsEnabled()))
        {
            action.Execute();
        }
    };
    if (ImGui::BeginPopup("##context-menu"))
    {
        auto popupPosition = ImGui::GetMousePosOnOpeningCurrentPopup();
        auto mostRecentlyOpenFiles = GetMostRecentlyOpenFileList();
        UI.m_PopupMousePos = popupPosition;
        menuAction(UI.m_File_Open);
        ImGui::Separator();
        menuAction(UI.m_File_Import);
        ImGui::Separator();
        if (ImGui::BeginMenu(ICON_NODE_OPEN " Open Recent...", !mostRecentlyOpenFiles.GetList().empty()))
        {
            for (auto& entry : mostRecentlyOpenFiles.GetList())
            {
                string title = string(ICON_NODE_FILE) + " " + entry;
                if (ImGui::MenuItem(title.c_str()))
                {
                    UI.File_Open(entry.c_str());
                }
            }
            ImGui::Separator();
            if (ImGui::MenuItem(ICON_NODE_CLEAR " Clear Recently Opened"))
                mostRecentlyOpenFiles.Clear();
            ImGui::EndMenu();
        }
        ImGui::Separator();
        if (ImGui::BeginMenu(ICON_BLUEPRINT_STYLE " Set Style"))
        {
            ImGui::Bullet();
            if (ImGui::MenuItem("Light##BluePrintStyle"))
            {
                UI.SetStyle(BluePrintStyle::BP_Style_BluePrint);
                ed::SetTheme(BPStyleToString(BluePrintStyle::BP_Style_BluePrint));
            }
            ImGui::Bullet();
            if (ImGui::MenuItem("Dark##BluePrintStyle"))
            {
                UI.SetStyle(BluePrintStyle::BP_Style_Dark);
                ed::SetTheme(BPStyleToString(BluePrintStyle::BP_Style_Dark));
            }
            ImGui::Bullet();
            if (ImGui::MenuItem("Mono##BluePrintStyle"))
            {
                UI.SetStyle(BluePrintStyle::BP_Style_Mono);
                ed::SetTheme(BPStyleToString(BluePrintStyle::BP_Style_Mono));
            }
            ImGui::EndMenu();
        }
        ImGui::Separator();
        menuAction(UI.m_File_New);
        ImGui::Separator();
        menuAction(UI.m_File_Save);
        ImGui::Separator();
        menuAction(UI.m_File_SaveAs);
        ImGui::Separator();
        menuAction(UI.m_View_ShowFlow);
        ImGui::Separator();
        menuAction(UI.m_View_ZoomToContent);
        ImGui::Separator();
        menuAction(UI.m_View_ZoomToSelection);
        ImGui::Separator();
        menuAction(UI.m_View_ShowMeters);
        ImGui::Separator();
        if (ImGui::BeginMenu(ICON_NEW_NODE " Add Node"))
        {
            UI.ShowNewNodeMenu(popupPosition);
            ImGui::EndMenu();
        }
        ImGui::EndPopup();
    }
}

// ---------------------------
// ----[ NodeContextMenu ]----
// ---------------------------
void NodeContextMenu::Open(Node* node/* = nullptr*/)
{
    ImGui::GetStateStorage()->SetVoidPtr(ImGui::GetID("##node-context-menu-node"), node);
    ImGui::OpenPopup("##node-context-menu");
}

void NodeContextMenu::Show(BluePrintUI& UI)
{
    if (!ImGui::IsPopupOpen("##node-context-menu"))
        return;
    //auto blueprint = &UI.m_Document->m_Blueprint;
    auto storage = ImGui::GetStateStorage();
    auto node = reinterpret_cast<Node*>(storage->GetVoidPtr(ImGui::GetID("##node-context-menu-node")));

    ed::ClearSelection();
    ed::SelectNode(node->m_ID);
    auto menuAction = [](Action& action)
    {
        if (ImGui::MenuItem((action.GetIcon() + " " + action.GetName()).c_str(), nullptr, nullptr, action.IsEnabled()))
        {
            action.Execute();
        }
    };
    if (ImGui::BeginPopup("##node-context-menu"))
    {
        menuAction(UI.m_Edit_Cut);
        ImGui::Separator();
        menuAction(UI.m_Edit_Copy);
        ImGui::Separator();
        menuAction(UI.m_Edit_Duplicate);
        ImGui::Separator();
        menuAction(UI.m_Edit_Delete);
        //if (node->HasSetting())
        //{
        //    ImGui::Separator();
        //    menuAction(UI.m_Edit_Setting);
        //}
        if (node->GetStyle() == NodeStyle::Default)
        {
            ImGui::Separator();
            menuAction(UI.m_Blueprint_BreakPoint);
        }
        ImGui::Separator();
        node->DrawMenuLayout(ImGui::GetCurrentContext());
        ImGui::EndPopup();
    }
}

// --------------------------
// ----[ PinContextMenu ]----
// --------------------------

void PinContextMenu::PinContextMenu::Open(Pin* pin /*= nullptr*/)
{
    ImGui::GetStateStorage()->SetVoidPtr(ImGui::GetID("##pin-context-menu-pin"), pin);
    ImGui::OpenPopup("##pin-context-menu");
}

void PinContextMenu::PinContextMenu::Show(BluePrintUI& UI)
{
    if (!ImGui::IsPopupOpen("##pin-context-menu"))
        return;

    /*
    auto storage = ImGui::GetStateStorage();
    auto pin = reinterpret_cast<Pin*>(storage->GetVoidPtr(ImGui::GetID("##pin-context-menu-pin")));
    if (ImGui::BeginPopup("##pin-context-menu"))
    {
        ImGui::Bullet();
        if (ImGui::MenuItem("Export", "", &pin->m_Exported))
        {
            ed::SetPinChanged(pin->m_ID);
            UI.m_Document->m_IsModified = true;
        }
        ImGui::EndPopup();
    }
    */
}

// ---------------------------
// ----[ LinkContextMenu ]----
// ---------------------------
void LinkContextMenu::Open(Pin* pin /*= nullptr*/)
{
    // check link is linked with export pin, we don't allow break export link
    if (pin->IsLinkedExportedPin())
        return;

    ImGui::GetStateStorage()->SetVoidPtr(ImGui::GetID("##link-context-menu-pin"), pin);
    ImGui::OpenPopup("##link-context-menu");
}

void LinkContextMenu::Show(BluePrintUI& UI)
{
    if (!ImGui::IsPopupOpen("##link-context-menu"))
        return;

    BP& blueprint = UI.m_Document->m_Blueprint;
    auto storage = ImGui::GetStateStorage();
    auto pin = reinterpret_cast<Pin*>(storage->GetVoidPtr(ImGui::GetID("##link-context-menu-pin")));

    if (ImGui::BeginPopup("##link-context-menu"))
    {
        if (ImGui::MenuItem("Break Link"))
        {
            if (pin && !ed::IsLinkSelected(pin->m_ID))
            {
                ed::DeleteLink(pin->m_ID);
            }
            else
            {
                auto selectedLinks = GetSelectedLinks(blueprint);
                for (auto selectedLink : selectedLinks)
                    ed::DeleteLink(selectedLink->m_ID);
            }
            UI.m_Document->m_IsModified = true;
        }

        ImGui::EndPopup();
    }
}

// ----------------------------
// ----[ NodeSettingDialog ]----
// ----------------------------
void NodeSettingDialog::Open(Node* node)
{
    ImGui::GetStateStorage()->SetVoidPtr(ImGui::GetID("##setting-node"), node);
    ImGui::OpenPopup("##setting_node_dialog");
}

void NodeSettingDialog::Show(BluePrintUI& UI)
{
    if (!ImGui::IsPopupOpen("##setting_node_dialog"))
        return;
    
    auto storage = ImGui::GetStateStorage();
    auto node = reinterpret_cast<Node*>(storage->GetVoidPtr(ImGui::GetID("##setting-node")));

    ImVec2 center = ImGui::GetMainViewport()->GetCenter();
    ImGui::SetNextWindowPos(center, ImGuiCond_Appearing, ImVec2(0.5f, 0.5f));
    if (ImGui::BeginPopupModal("##setting_node_dialog", NULL, ImGuiWindowFlags_AlwaysAutoResize | ImGuiWindowFlags_NoSavedSettings))
    {
        ImGui::Text("Setting %" PRI_node "\n", FMT_node(node));
        ImGui::Separator();
        node->DrawSettingLayout(ImGui::GetCurrentContext());
        ImGui::Separator();
        if (ImGui::Button("OK", ImVec2(120, 0))) 
        {
            UI.m_Document->m_IsModified = true;
            ed::SetNodeChanged(node->m_ID);
            ImGui::CloseCurrentPopup();
        }
        ImGui::EndPopup();
    }
}

// ----------------------------
// ----[ NodeDeleteDialog ]----
// ----------------------------
void NodeDeleteDialog::Open(Node* node /* = nullptr */)
{
    ImGui::GetStateStorage()->SetVoidPtr(ImGui::GetID("##delete-node"), node);
    ImGui::OpenPopup("##delete_node_dialog");
}

void NodeDeleteDialog::Show(BluePrintUI& UI)
{
    if (!ImGui::IsPopupOpen("##delete_node_dialog"))
        return;
    
    auto storage = ImGui::GetStateStorage();
    auto node = reinterpret_cast<Node*>(storage->GetVoidPtr(ImGui::GetID("##delete-node")));

    ImVec2 center = ImGui::GetMainViewport()->GetCenter();
    ImGui::SetNextWindowPos(center, ImGuiCond_Appearing, ImVec2(0.5f, 0.5f));
    if (ImGui::BeginPopupModal("##delete_node_dialog", NULL, ImGuiWindowFlags_AlwaysAutoResize | ImGuiWindowFlags_NoSavedSettings))
    {
        ImGui::Text("Delete %" PRI_node "?\n", FMT_node(node));
        ImGui::Separator();
        if (ImGui::Button("OK", ImVec2(120, 0))) 
        {
            ed::DeleteNode(node->m_ID);
            UI.m_Document->m_IsModified = true;
            // ed::SetNodeChanged(node->m_ID); // Dont do that because save deleted node will cause crush
            ImGui::CloseCurrentPopup();
        }
        ImGui::SetItemDefaultFocus();
        ImGui::SameLine();
        if (ImGui::Button("Cancel", ImVec2(120, 0))) { ImGui::CloseCurrentPopup(); }
        ImGui::EndPopup();
    }
}

void NodeCreateDialog::Open(Pin* fromPin)
{
    auto storage = ImGui::GetStateStorage();
    storage->SetVoidPtr(ImGui::GetID("##create_node_pin"), fromPin);
    ImGui::OpenPopup("##create_node");
}

void NodeCreateDialog::Show(BluePrintUI& UI)
{
    if (!ImGui::IsPopupOpen("##create_node"))
    {
        UI.m_isNewNodePopuped = false;
        UI.m_newNodeLinkPin = nullptr;
        return;
    }

    auto storage = ImGui::GetStateStorage();
    auto fromPin = reinterpret_cast<Pin*>(storage->GetVoidPtr(ImGui::GetID("##create_node_pin")));
    if (!ImGui::BeginPopup("##create_node"))
    {
        UI.m_isNewNodePopuped = false;
        UI.m_newNodeLinkPin = nullptr;
        return;
    }
    
    auto popupPosition = ImGui::GetMousePosOnOpeningCurrentPopup();
    auto node = UI.ShowNewNodeMenu(popupPosition);
    if (node)
    {
        m_CreatedNode = node;
        m_CreatedLinks.clear();
        if (fromPin)
        {
            auto newLinks = CreateLinkToFirstMatchingPin(*node, *fromPin);
            for (auto startPin : newLinks)
                LOGI("[NodeCreateDialog] %" PRI_pin "  linked with %" PRI_pin, FMT_pin(startPin), FMT_pin(startPin->GetLink()));
        }
        ed::SetNodeChanged(node->m_ID);
    }
    ImGui::EndPopup();
}

std::vector<Pin*> NodeCreateDialog::CreateLinkToFirstMatchingPin(Node& node, Pin& fromPin)
{
    for (auto nodePin : node.GetInputPins())
    {
        if (nodePin->LinkTo(fromPin))
            return { nodePin };
        if (fromPin.LinkTo(*nodePin))
            return { &fromPin };
    }
    for (auto nodePin : node.GetOutputPins())
    {
        if (nodePin->LinkTo(fromPin))
            return { nodePin };
        if (fromPin.LinkTo(*nodePin))
            return { &fromPin };
    }
    return {};
}
} // namespace BluePrint

namespace BluePrint
{
BluePrintUI::BluePrintUI()
{
    m_StyleColors[BluePrintStyleColor_TitleBg]              = ImColor(255, 255, 255,  64);
    m_StyleColors[BluePrintStyleColor_TitleBgDummy]         = ImColor(255,   0,   0,  64);
    m_StyleColors[BluePrintStyleColor_GroupBg]              = ImColor(128, 128, 128, 128);
    m_StyleColors[BluePrintStyleColor_Border]               = ImColor(255, 255, 255,  64);
    m_StyleColors[BluePrintStyleColor_DummyBorder]          = ImColor(255,   0,  32, 200);
    m_StyleColors[BluePrintStyleColor_ToolButton]           = ImColor(255, 255, 255,   0);
    m_StyleColors[BluePrintStyleColor_ToolButtonActive]     = ImColor(192, 192, 192, 192);
    m_StyleColors[BluePrintStyleColor_ToolButtonHovered]    = ImColor(192, 192, 255, 128);
    m_StyleColors[BluePrintStyleColor_DebugCurrentNode]     = ImColor(  0, 255,   0, 128);
    m_StyleColors[BluePrintStyleColor_DebugNextNode]        = ImColor(  0,   0, 255, 128);
    m_StyleColors[BluePrintStyleColor_DebugBreakPointNode]  = ImColor(255,   0,   0, 128);
    m_StyleColors[BluePrintStyleColor_PinVoid]              = ImColor(255, 255, 255, 255);
    m_StyleColors[BluePrintStyleColor_PinAny]               = ImColor(255, 255, 255, 255);
    m_StyleColors[BluePrintStyleColor_PinFlow]              = ImColor(255, 255, 255, 255);
    m_StyleColors[BluePrintStyleColor_PinBool]              = ImColor( 48, 48,  220, 255);
    m_StyleColors[BluePrintStyleColor_PinInt32]             = ImColor( 68, 201, 156, 255);
    m_StyleColors[BluePrintStyleColor_PinInt64]             = ImColor(100,  34,  78, 255);
    m_StyleColors[BluePrintStyleColor_PinFloat]             = ImColor(147, 226,  74, 255);
    m_StyleColors[BluePrintStyleColor_PinDouble]            = ImColor( 72, 113,  37, 255);
    m_StyleColors[BluePrintStyleColor_PinString]            = ImColor(124,  21, 153, 255);
    m_StyleColors[BluePrintStyleColor_PinPoint]             = ImColor(220, 110,  10, 255);
    m_StyleColors[BluePrintStyleColor_PinVector]            = ImColor( 72, 110, 220, 255);
    m_StyleColors[BluePrintStyleColor_PinMat]               = ImColor(220, 220, 110, 255);
    m_StyleColors[BluePrintStyleColor_PinCustom]            = ImColor(208,  64,  64, 255);
}

void BluePrintUI::Initialize(const char * ini_file, const char * bp_file, const char * plugin_path)
{
    m_OverlayLogger = new OverlayLogger();
    OverlayLogger::SetCurrent(m_OverlayLogger);
    m_OverlayLogger->AddKeyword("Node");
    m_OverlayLogger->AddKeyword("Pin");
    m_OverlayLogger->AddKeyword("Link");
    m_OverlayLogger->AddKeyword("ContextMenu");
    m_OverlayLogger->AddKeyword("NodeContextMenu");
    m_OverlayLogger->AddKeyword("PinContextMenu");
    m_OverlayLogger->AddKeyword("LinkContextMenu");
    m_OverlayLogger->AddKeyword("NodeDeleteDialog");
    m_OverlayLogger->AddKeyword("NodeCreateDialog");
    m_OverlayLogger->AddKeyword("NodeSettingDialog");

    ImGui::MostRecentlyUsedList::Install(ImGui::GetCurrentContext());

#if !defined(__EMSCRIPTEN__)
    m_Config.SettingsFile = nullptr;
#endif
    InstallDocumentCallbacks();
    m_Editor = ed::CreateEditor(&m_Config);
    ed::SetCurrentEditor(m_Editor);
    m_Document = make_unique<BluePrint::Document>();
    m_Document->m_OverlayLogger = m_OverlayLogger;

    // load dynamic node
    auto nodeRegistry = m_Document->m_Blueprint.GetNodeRegistry();
    std::string plugin_real_path = plugin_path ? std::string(plugin_path) : "";
    std::vector<std::string> plugins, plugin_names;
    if (DIR_Iterate(plugin_real_path, plugins, plugin_names, false, ".node") == 0)
    {
        LOGI("Load Extra Node %s", plugin_real_path.c_str());
        for (auto node_path : plugins)
        {
            auto nodetypeid = nodeRegistry->RegisterNodeType(node_path, m_Document->m_Blueprint);
            if (nodetypeid == 0)
            {
                LOGE("Load Extra Node Failed %s", node_path.c_str());
                continue;
            }
            auto nodeinfo = nodeRegistry->GetTypeInfo(nodetypeid);
            if (!nodeinfo)
            {
                LOGE("Load Extra Node Failed %s", node_path.c_str());
                continue;
            }
            LOGI("Load Extra Node %s(%d.%d.%d.%d)", nodeinfo->m_NodeTypeName.c_str(),
                                                    VERSION_MAJOR(nodeinfo->m_Version), 
                                                    VERSION_MINOR(nodeinfo->m_Version), 
                                                    VERSION_PATCH(nodeinfo->m_Version), 
                                                    VERSION_BUILT(nodeinfo->m_Version));
        }
    }

    // load dynamic pin
    auto pinexRegistry = m_Document->m_Blueprint.GetPinExRegistry();
    plugins.clear(); plugin_names.clear();
    if (DIR_Iterate(plugin_real_path, plugins, plugin_names, false, ".pin") == 0)
    {
        LOGI("Load Extra PinEx %s", plugin_real_path.c_str());
        for (auto pinex_path : plugins)
        {
            auto pPinexType = pinexRegistry->RegisterPinEx(pinex_path);
            if (pPinexType == nullptr) {
                LOGE("FAILED to load PinEx from '%s'!", pinex_path.c_str());
                continue;
            }
            LOGI("Successfully loaded PinEx from '%s'!", pinex_path.c_str());
        }
    }

    if (!bp_file || m_Document->Load(bp_file) != BP_ERR_NONE)
    {
        if (bp_file)
            LOGE("Load BluePrint file %s Failed!!! We will build new file.", bp_file);
        else
            LOGE("No BluePrint file set!!! We will build new file.");
        CreateNewDocument();
    }

    m_Document->SetPath(bp_file);
    m_Document->OnMakeCurrent();

    for (auto nodeTypeInfo : m_Document->m_Blueprint.GetNodeRegistry()->GetTypes())
            m_OverlayLogger->AddKeyword(nodeTypeInfo->m_Name);

    for (auto node : m_Document->m_Blueprint.GetNodes())
    {
        if (node->GetType() == NodeType::External && 
            node->NeedOverlayLogger())
        {
            node->SetLogger(m_OverlayLogger);
        }
    }

    m_DebugOverlay = new DebugOverlay();
    m_DebugOverlay->Init(&m_Document->m_Blueprint);
    std::string theme = ed::GetTheme();
    SetStyle(BPStyleFromName(theme));
    ed::SetCurrentEditor(nullptr);
    InitFileDialog();
#if !defined(__EMSCRIPTEN__)
    m_ClipBoard.clear();
#endif
}

void BluePrintUI::Finalize()
{
    ed::SetCurrentEditor(m_Editor);
    m_Document->Save();
    m_Document = nullptr;
    ed::SetCurrentEditor(nullptr);
    ed::DestroyEditor(m_Editor);
    m_Editor = nullptr;
    // TODO::Dicky Don't know why release those resource will cause App fail at end.
    //if (m_OverlayLogger) { delete m_OverlayLogger; m_OverlayLogger = nullptr; }
    //if (m_DebugOverlay) { delete m_DebugOverlay; m_DebugOverlay = nullptr; }
#ifdef USE_BOOKMARK
	// save bookmarks
	std::ofstream configFileWriter(m_BookMarkPath, std::ios::out);
	if (!configFileWriter.bad())
	{
		configFileWriter << m_FileDialog.SerializeBookmarks();
		configFileWriter.close();
	}
#endif
}

void BluePrintUI::SetStyle(enum BluePrintStyle style)
{
    auto& io = ImGui::GetIO();
    switch (style)
    {
    case BluePrintStyle::BP_Style_BluePrint:
        {
            ImGui::StyleColorsLight();
            if (m_Document) m_Document->m_Blueprint.SetStyleLight(true);
            m_FileDialog.SetLightStyle();
            m_StyleColors[BluePrintStyleColor_GroupBg]              = ImColor(128, 128, 255, 128);
            m_StyleColors[BluePrintStyleColor_TitleBg]              = ImColor(128, 128, 255,  64);
            m_StyleColors[BluePrintStyleColor_ToolButtonActive]     = ImColor( 96,  96, 255, 192);
            m_StyleColors[BluePrintStyleColor_ToolButtonHovered]    = ImColor( 96,  96, 255, 128);
            m_StyleColors[BluePrintStyleColor_DebugCurrentNode]     = ImColor(  0, 255,   0, 128);
            m_StyleColors[BluePrintStyleColor_DebugNextNode]        = ImColor(  0,   0, 255, 128);
            m_StyleColors[BluePrintStyleColor_DebugBreakPointNode]  = ImColor(255,   0,   0, 128);
            m_StyleColors[BluePrintStyleColor_PinVoid]      = ImColor(   0,   0,   0, 255);
            m_StyleColors[BluePrintStyleColor_PinAny]       = ImColor(   0,   0,   0, 200);
            m_StyleColors[BluePrintStyleColor_PinFlow]      = ImColor(   0,   0,   0, 200);
            m_StyleColors[BluePrintStyleColor_PinBool]      = ImColor(  48, 48,  220, 255);
            m_StyleColors[BluePrintStyleColor_PinInt32]     = ImColor(  68, 201, 156, 255);
            m_StyleColors[BluePrintStyleColor_PinInt64]     = ImColor( 100,  34,  78, 255);
            m_StyleColors[BluePrintStyleColor_PinFloat]     = ImColor(  74, 113,  37, 255);
            m_StyleColors[BluePrintStyleColor_PinDouble]    = ImColor(  36,  56,  17, 255);
            m_StyleColors[BluePrintStyleColor_PinString]    = ImColor( 124,  21, 153, 255);
            m_StyleColors[BluePrintStyleColor_PinPoint]     = ImColor( 220, 110,  10, 255);
            m_StyleColors[BluePrintStyleColor_PinVector]    = ImColor(  72, 110, 220, 255);
            m_StyleColors[BluePrintStyleColor_PinMat]       = ImColor( 110, 180,  10, 255);
            m_StyleColors[BluePrintStyleColor_PinCustom]    = ImColor( 208,  64,  64, 255);
            auto& editorStyle = ed::GetStyle();
            editorStyle.Colors[ed::StyleColor_Bg]           = ImColor( 220, 220, 252,  72);
            editorStyle.Colors[ed::StyleColor_NodeBg]       = ImColor( 200, 200, 230, 228);
            editorStyle.Colors[ed::StyleColor_NodeBorder]   = ImColor( 128, 128, 255,  96);
            editorStyle.Colors[ed::StyleColor_SelNodeBorder]= ImColor(  20,  20, 255, 255);
            editorStyle.Colors[ed::StyleColor_HovNodeBorder]= ImColor(  50, 176, 255, 255);
            editorStyle.Colors[ed::StyleColor_Flow]         = ImColor(  64, 128,  64, 255);
            editorStyle.Colors[ed::StyleColor_FlowDMarker]  = ImColor( 255, 128,  10, 255);
            editorStyle.Colors[ed::StyleColor_FlowMarker]   = ImColor( 128, 255, 128, 255);
            if (m_OverlayLogger)
            {
                m_OverlayLogger->SetLogColor(LogColor_LogTimeColor,     ImColor( 75, 105,   0, 255));
                m_OverlayLogger->SetLogColor(LogColor_LogStringColor,   ImColor(128,  87,  66, 255));
                m_OverlayLogger->SetLogColor(LogColor_LogKeywordColor,  ImColor(  0,   0,   0, 255));
                m_OverlayLogger->SetLogColor(LogColor_LogTextColor,     ImColor( 96,  96,  96, 255));
                m_OverlayLogger->SetLogColor(LogColor_LogOutlineColor,  ImColor( 20,  20,  20,  64));
                m_OverlayLogger->SetLogColor(LogColor_LogNumberColor,   ImColor(128, 128,  64, 255));
                m_OverlayLogger->SetLogColor(LogColor_LogVerboseColor,  ImColor( 64, 128,  64, 255));
                m_OverlayLogger->SetLogColor(LogColor_LogWarningColor,  ImColor(128, 128,  96, 255));
                m_OverlayLogger->SetLogColor(LogColor_LogErrorColor,    ImColor(128,  76,  76, 255));
                m_OverlayLogger->SetLogColor(LogColor_LogInfoColor,     ImColor( 69,  99, 128, 255));
                m_OverlayLogger->SetLogColor(LogColor_LogAssertColor,   ImColor(128,  30,  34, 255));
            }
        }
        break;
    case BluePrintStyle::BP_Style_Dark:
        {
            ImGui::StyleColorsDark();
            m_FileDialog.SetDarkStyle();
            if (m_Document) m_Document->m_Blueprint.SetStyleLight(false);
            m_StyleColors[BluePrintStyleColor_TitleBg]              = ImColor(255, 255, 255,  64);
            m_StyleColors[BluePrintStyleColor_TitleBgDummy]         = ImColor(255,   0,   0,  64);
            m_StyleColors[BluePrintStyleColor_GroupBg]              = ImColor(128, 128, 128, 128);
            m_StyleColors[BluePrintStyleColor_Border]               = ImColor(255, 255, 255,  64);
            m_StyleColors[BluePrintStyleColor_DummyBorder]          = ImColor(255,   0,  32, 200);
            m_StyleColors[BluePrintStyleColor_ToolButton]           = ImColor(255, 255, 255,   0);
            m_StyleColors[BluePrintStyleColor_ToolButtonActive]     = ImColor(192, 192, 192, 192);
            m_StyleColors[BluePrintStyleColor_ToolButtonHovered]    = ImColor(192, 192, 255, 128);
            m_StyleColors[BluePrintStyleColor_DebugCurrentNode]     = ImColor(  0, 255,   0, 128);
            m_StyleColors[BluePrintStyleColor_DebugNextNode]        = ImColor(  0,   0, 255, 128);
            m_StyleColors[BluePrintStyleColor_DebugBreakPointNode]  = ImColor(255,   0,   0, 128);
            m_StyleColors[BluePrintStyleColor_PinVoid]              = ImColor(255, 255, 255, 255);
            m_StyleColors[BluePrintStyleColor_PinAny]               = ImColor(255, 255, 255, 255);
            m_StyleColors[BluePrintStyleColor_PinFlow]              = ImColor(255, 255, 255, 255);
            m_StyleColors[BluePrintStyleColor_PinBool]              = ImColor( 48, 48,  220, 255);
            m_StyleColors[BluePrintStyleColor_PinInt32]             = ImColor( 68, 201, 156, 255);
            m_StyleColors[BluePrintStyleColor_PinInt64]             = ImColor(100,  34,  78, 255);
            m_StyleColors[BluePrintStyleColor_PinFloat]             = ImColor(147, 226,  74, 255);
            m_StyleColors[BluePrintStyleColor_PinDouble]            = ImColor( 72, 113,  37, 255);
            m_StyleColors[BluePrintStyleColor_PinString]            = ImColor(124,  21, 153, 255);
            m_StyleColors[BluePrintStyleColor_PinPoint]             = ImColor(220, 110,  10, 255);
            m_StyleColors[BluePrintStyleColor_PinVector]            = ImColor( 72, 110, 220, 255);
            m_StyleColors[BluePrintStyleColor_PinMat]               = ImColor(220, 220, 110, 255);
            m_StyleColors[BluePrintStyleColor_PinCustom]            = ImColor(208,  64,  64, 255);
            auto& editorStyle = ed::GetStyle();
            editorStyle.Colors[ed::StyleColor_Bg]           = ImColor( 60,  60,  70,  50);
            editorStyle.Colors[ed::StyleColor_NodeBg]       = ImColor( 32,  32,  32, 228);
            editorStyle.Colors[ed::StyleColor_NodeBorder]   = ImColor(255, 255, 255,  96);
            editorStyle.Colors[ed::StyleColor_SelNodeBorder]= ImColor(255, 176,  50, 255);
            editorStyle.Colors[ed::StyleColor_HovNodeBorder]= ImColor( 50, 176, 255, 255);
            editorStyle.Colors[ed::StyleColor_Flow]         = ImColor( 64, 128,  64, 255);
            editorStyle.Colors[ed::StyleColor_FlowDMarker]  = ImColor(255, 128,  10, 255);
            editorStyle.Colors[ed::StyleColor_FlowMarker]   = ImColor(128, 255, 128, 255);
            if (m_OverlayLogger)
            {
                m_OverlayLogger->SetLogColor(LogColor_LogTimeColor,     ImColor(150, 209,   0, 255));
                m_OverlayLogger->SetLogColor(LogColor_LogSymbolColor,   ImColor(192, 192, 192, 255));
                m_OverlayLogger->SetLogColor(LogColor_LogStringColor,   ImColor(255, 174, 133, 255));
                m_OverlayLogger->SetLogColor(LogColor_LogTagColor,      ImColor(255, 214, 143, 255));
                m_OverlayLogger->SetLogColor(LogColor_LogKeywordColor,  ImColor(255, 255, 255, 255));
                m_OverlayLogger->SetLogColor(LogColor_LogTextColor,     ImColor(192, 192, 192, 255));
                m_OverlayLogger->SetLogColor(LogColor_LogOutlineColor,  ImColor(  0,   0,   0, 255));
                m_OverlayLogger->SetLogColor(LogColor_LogNumberColor,   ImColor(255, 255, 128, 255));
                m_OverlayLogger->SetLogColor(LogColor_LogVerboseColor,  ImColor(128, 255, 128, 255));
                m_OverlayLogger->SetLogColor(LogColor_LogWarningColor,  ImColor(255, 255, 192, 255));
                m_OverlayLogger->SetLogColor(LogColor_LogErrorColor,    ImColor(255, 152, 152, 255));
                m_OverlayLogger->SetLogColor(LogColor_LogInfoColor,     ImColor(138, 197, 255, 255));
                m_OverlayLogger->SetLogColor(LogColor_LogAssertColor,   ImColor(255,  61,  68, 255));
            }
        }
        break;
    case BluePrintStyle::BP_Style_Mono:
        {
            ImGui::StyleColorsLight();
            m_FileDialog.SetLightStyle();
            if (m_Document) m_Document->m_Blueprint.SetStyleLight(true);
            m_StyleColors[BluePrintStyleColor_GroupBg]              = ImColor(196, 196, 196, 196);
            m_StyleColors[BluePrintStyleColor_TitleBg]              = ImColor(128, 128, 128,  64);
            m_StyleColors[BluePrintStyleColor_ToolButtonActive]     = ImColor( 96,  96, 96, 192);
            m_StyleColors[BluePrintStyleColor_ToolButtonHovered]    = ImColor( 96,  96, 96, 128);
            m_StyleColors[BluePrintStyleColor_PinVoid]      = ImColor(   0,   0,   0, 255);
            m_StyleColors[BluePrintStyleColor_PinAny]       = ImColor(   0,   0,   0, 200);
            m_StyleColors[BluePrintStyleColor_PinFlow]      = ImColor(   0,   0,   0, 200);
            m_StyleColors[BluePrintStyleColor_PinBool]      = ImColor(  48,  48,   48, 255);
            m_StyleColors[BluePrintStyleColor_PinInt32]     = ImColor( 128, 128, 128, 255);
            m_StyleColors[BluePrintStyleColor_PinInt64]     = ImColor( 144, 144, 144, 255);
            m_StyleColors[BluePrintStyleColor_PinFloat]     = ImColor(  74,  74,  74, 255);
            m_StyleColors[BluePrintStyleColor_PinDouble]    = ImColor(  36,  36,  36, 255);
            m_StyleColors[BluePrintStyleColor_PinString]    = ImColor(  48,  48,  48, 255);
            m_StyleColors[BluePrintStyleColor_PinPoint]     = ImColor(  64,  64,  64, 255);
            m_StyleColors[BluePrintStyleColor_PinVector]    = ImColor(  32,  32,  32, 255);
            m_StyleColors[BluePrintStyleColor_PinMat]       = ImColor(110, 110, 110, 255);
            m_StyleColors[BluePrintStyleColor_PinCustom]    = ImColor(  20,  20,  20, 255);
            m_StyleColors[BluePrintStyleColor_DebugCurrentNode]     = ImColor(   0,   0,   0, 128);
            m_StyleColors[BluePrintStyleColor_DebugNextNode]        = ImColor(  64,  64,  64, 128);
            m_StyleColors[BluePrintStyleColor_DebugBreakPointNode]  = ImColor(   0,   0,   0, 128);

            auto& editorStyle = ed::GetStyle();
            editorStyle.Colors[ed::StyleColor_Bg]           = ImColor( 220, 220, 220,  72);
            editorStyle.Colors[ed::StyleColor_NodeBg]       = ImColor( 200, 200, 200, 228);
            editorStyle.Colors[ed::StyleColor_NodeBorder]   = ImColor( 128, 128, 128,  96);
            editorStyle.Colors[ed::StyleColor_SelNodeBorder]= ImColor(  20,  20,  20, 255);
            editorStyle.Colors[ed::StyleColor_HovNodeBorder]= ImColor(  72,  72,  72, 255);
            editorStyle.Colors[ed::StyleColor_Flow]         = ImColor(  64,  64,  64, 255);
            editorStyle.Colors[ed::StyleColor_FlowDMarker]  = ImColor(  32,  32,  32, 255);
            editorStyle.Colors[ed::StyleColor_FlowMarker]   = ImColor(  10,  10,  10, 128);
            if (m_OverlayLogger)
            {
                m_OverlayLogger->SetLogColor(LogColor_LogTimeColor,     ImColor( 75,  75,  75, 255));
                m_OverlayLogger->SetLogColor(LogColor_LogStringColor,   ImColor(128, 128, 128, 255));
                m_OverlayLogger->SetLogColor(LogColor_LogKeywordColor,  ImColor(  0,   0,   0, 255));
                m_OverlayLogger->SetLogColor(LogColor_LogTextColor,     ImColor( 96,  96,  96, 255));
                m_OverlayLogger->SetLogColor(LogColor_LogOutlineColor,  ImColor( 20,  20,  20,  64));
                m_OverlayLogger->SetLogColor(LogColor_LogNumberColor,   ImColor(128, 128, 128, 255));
                m_OverlayLogger->SetLogColor(LogColor_LogVerboseColor,  ImColor( 64,  64,  64, 255));
                m_OverlayLogger->SetLogColor(LogColor_LogWarningColor,  ImColor( 96,  96,  96, 255));
                m_OverlayLogger->SetLogColor(LogColor_LogErrorColor,    ImColor( 76,  76,  76, 255));
                m_OverlayLogger->SetLogColor(LogColor_LogInfoColor,     ImColor( 69,  69,  69, 255));
                m_OverlayLogger->SetLogColor(LogColor_LogAssertColor,   ImColor( 30,  30,  30, 255));
            }
        }
        break;
    default:
        break;
    }
    m_Style = style;
}

bool BluePrintUI::Frame()
{
    bool done = false;
    if (!m_Editor || !m_Document)
        return true;
    auto& io = ImGui::GetIO();
    ImGui::SetNextWindowPos(ImVec2(0, 0));
    ImGui::SetNextWindowSize(io.DisplaySize);
    ImGui::Begin("Content", nullptr,
                ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoMove |
                ImGuiWindowFlags_NoScrollbar | ImGuiWindowFlags_NoScrollWithMouse | ImGuiWindowFlags_NoSavedSettings |
                ImGuiWindowFlags_NoBringToFrontOnFocus);

        ed::SetCurrentEditor(m_Editor);
        UpdateActions();
        ShowToolbar();
        m_OverlayLogger->Draw(ImGui::GetItemRectMin(), io.DisplaySize); // Put here will show logger on background
        ed::Begin("###main_editor");
            DrawNodes();
            HandleCreateAction();
            HandleDestroyAction();
            HandleContextMenuAction();
            ShowDialogs();
            DrawInfoTooltip();
            if (m_isNewNodePopuped && m_newNodeLinkPin != nullptr)
            {
                ed::DrawLastLine(m_Style == BluePrintStyle::BP_Style_BluePrint);
            }
        ed::End();
        FileDialogs();
        m_OverlayLogger->Update(ImGui::GetIO().DeltaTime);
        //m_OverlayLogger->Draw(ImGui::GetItemRectMin(), io.DisplaySize); // Put here will show logger on foreground
        ed::SetCurrentEditor(nullptr); // Don't Stop ed?
    ImGui::End();
    return done;
}

void BluePrintUI::CreateNewDocument()
{
    auto blueprint = &m_Document->m_Blueprint;
    auto entryPointNode =   blueprint->CreateNode<BluePrint::EntryPointNode>();
                            ed::SetNodePosition(entryPointNode->m_ID, ImVec2(40, 80));
}

void BluePrintUI::InstallDocumentCallbacks()
{
    m_Config.UserPointer = this;
    m_Config.BeginSaveSession = [](void* userPointer)
    {
        auto self = reinterpret_cast<BluePrintUI*>(userPointer);
        if (self && self->m_Document)
            self->m_Document->OnSaveBegin();
    };
    m_Config.EndSaveSession = [](void* userPointer)
    {
        auto self = reinterpret_cast<BluePrintUI*>(userPointer);
        if (self && self->m_Document)
            self->m_Document->OnSaveEnd();
    };
    m_Config.SaveSettingsJson = [](const imgui_json::value& state, ed::SaveReasonFlags reason, void* userPointer) -> bool
    {
        auto self = reinterpret_cast<BluePrintUI*>(userPointer);
        if (self && self->m_Document)
            return self->m_Document->OnSaveState(state, reason);
        else
            return false;
    };
    m_Config.LoadSettingsJson = [](void* userPointer) -> imgui_json::value
    {
        auto self = reinterpret_cast<BluePrintUI*>(userPointer);
        if (self && self->m_Document)
            return self->m_Document->OnLoadState();
        else
            return {};
    };
    m_Config.SaveNodeSettingsJson = [](ed::NodeId nodeId, const imgui_json::value& value, ed::SaveReasonFlags reason, void* userPointer) -> bool
    {
        auto self = reinterpret_cast<BluePrintUI*>(userPointer);
        if (self && self->m_Document)
            return self->m_Document->OnSaveNodeState(static_cast<ID_TYPE>(nodeId.Get()), value, reason);
        else
            return false;
    };
    m_Config.LoadNodeSettingsJson = [](ed::NodeId nodeId, void* userPointer) -> imgui_json::value
    {
        auto self = reinterpret_cast<BluePrintUI*>(userPointer);
        if (self && self->m_Document)
            return self->m_Document->OnLoadNodeState(static_cast<ID_TYPE>(nodeId.Get()));
        else
            return {};
    };

    struct TransactionWrapper final: ed::ITransaction
    {
        static const char* ActionToString(ed::TransactionAction action)
        {
            switch (action)
            {
                case ed::TransactionAction::Unknown:    return "Unknown";
                case ed::TransactionAction::Navigation: return "Navigation";
                case ed::TransactionAction::DragStart:  return "DragStart";
                case ed::TransactionAction::DragEnd:    return "DragEnd";
                case ed::TransactionAction::Resize:     return "Resize";
                default : return "";
            }
            return "";
        }
        TransactionWrapper(shared_ptr<BluePrint::Document::UndoTransaction> transaction)
            : m_Transaction(std::move(transaction))
        {
        }
        /*
        void AddAction(ed::TransactionAction action, const char* name) override
        {
            ++m_ActionCount;
            m_Transaction->AddAction("%s", name);
        }
        */
        void Commit() override
        {
            ImGuiTextBuffer name;
            if (m_ActionCount == m_DragActionCount && m_DragActionCount > 1)
                name.appendf("Drag %d nodes", static_cast<int>(m_DragActionCount));
            m_Transaction->Commit(name.c_str());
        }
        void Discard() override
        {
            m_Transaction->Discard();
        }
        void AddAction(ed::TransactionAction action, ed::NodeId nodeId, const char* name) override
        {
            auto& blueprint = m_Transaction->GetDocument()->GetBlueprint();
            auto  node = const_cast<BP&>(blueprint).FindNode(static_cast<ID_TYPE>(nodeId.Get()));
            if (!node)
                return;
            ++m_ActionCount;
            m_NodeIds.push_back(nodeId);
            if (action == ed::TransactionAction::DragStart)
            {
                ++m_DragActionCount;
                node->OnDragStart(blueprint.GetContext());
                m_Transaction->AddAction("Drag Start %" PRI_node, FMT_node(node));
            }
            else if (action == ed::TransactionAction::DragEnd)
            {
                ++m_DragActionCount;
                node->OnDragEnd(blueprint.GetContext());
                m_Transaction->AddAction("Drag End %" PRI_node, FMT_node(node));
            }
            else if (action == ed::TransactionAction::Resize)
            {
                node->OnResize(blueprint.GetContext());
                m_Transaction->AddAction("Resize %" PRI_node, FMT_node(node));
            }
            else if (action == ed::TransactionAction::Select)
            {
                node->OnSelect(blueprint.GetContext());
                m_Transaction->AddAction("Select %" PRI_node, FMT_node(node));
            }
            else if (action == ed::TransactionAction::Deselect)
            {
                node->OnDeselect(blueprint.GetContext());
                m_Transaction->AddAction("Deselect %" PRI_node, FMT_node(node));
            }
            else
                m_Transaction->AddAction("%s", name);
        }
        void AddAction(ed::TransactionAction action, ed::LinkId linkId, const char* name) override
        {
            auto& blueprint = m_Transaction->GetDocument()->GetBlueprint();
            auto  link = const_cast<BP&>(blueprint).FindPin(static_cast<ID_TYPE>(linkId.Get()));
            if (!link)
                return;
            ++m_ActionCount;
            m_Transaction->AddAction("%s Link %" PRIX32, name, link->m_ID);
        }
        shared_ptr<BluePrint::Document::UndoTransaction> m_Transaction;
        size_t m_ActionCount = 0;
        size_t m_DragActionCount = 0;
        vector<ed::NodeId> m_NodeIds;
    };
    m_Config.TransactionInterface.Constructor = [](const char* name, void* userPointer) -> ed::ITransaction*
    {
        auto self = reinterpret_cast<BluePrintUI*>(userPointer);
        if (!self || !self->m_Document) return nullptr;
        return new TransactionWrapper(self->m_Document->BeginUndoTransaction(name));
    };
    m_Config.TransactionInterface.Destructor = [](ed::ITransaction* transaction, void* userPointer)
    {
        delete transaction;
    };
    m_Config.TransactionInterface.UserPointer = this;
}

float BluePrintUI::DrawNodeToolBar(Node *node, Node **need_clone_node)
{
    if (!m_Document)
        return 0.f;
    // Draw Title bar icon
    int icons = 2; //node->HasSetting() ? 3 : 2;
    if (node->HasSetting()) icons++;
    if (node->GetStyle() == NodeStyle::Group) icons++;
    float textSizeButton = ImGui::CalcTextSize(titlebar_icons[0].c_str()).x;
#if IMGUI_ENABLE_FREETYPE || !IMGUI_ICONS
    textSizeButton *= 1.5;
#endif
    ImGui::SameLine(ed::GetNodeSize(node->m_ID).x - textSizeButton * (icons + 2) - (icons * 4));
    ImGui::PushStyleColor(ImGuiCol_Button, m_StyleColors[BluePrintStyleColor_ToolButton]);
    ImGui::PushStyleColor(ImGuiCol_ButtonHovered, m_StyleColors[BluePrintStyleColor_ToolButtonHovered]);
    ImGui::PushStyleColor(ImGuiCol_ButtonActive, m_StyleColors[BluePrintStyleColor_ToolButtonActive]);
    ImGui::PushStyleVar(ImGuiStyleVar_ItemSpacing, ImVec2(0,0));
    ImGui::PushStyleVar(ImGuiStyleVar_ItemInnerSpacing, ImVec2(0,0));
    ImGui::PushStyleVar(ImGuiStyleVar_TexGlyphShadowOffset, ImVec2(2.0, 2.0));
    if (ImGui::Button((titlebar_icons[0] + "##" + std::to_string(node->m_ID)).c_str())) 
    {
        *need_clone_node = node;
    }
    if (ImGui::IsItemHovered()) node->m_IconHovered = 0;

    ImGui::SameLine(0);
    if (ImGui::Button((titlebar_icons[1] + "##" + std::to_string(node->m_ID)).c_str())) 
    {
        ed::Suspend();
        LOGI("[HandleNodeToolBar] Open NodeDeleteDialog for %" PRI_node, FMT_node(node));
        m_NodeDeleteDialog.Open(node);
        ed::Resume();
    }
    if (ImGui::IsItemHovered()) node->m_IconHovered = 1;

    if (node->HasSetting())
    {
        ImGui::SameLine(0);
        if (ImGui::Button((titlebar_icons[2] + "##" + std::to_string(node->m_ID)).c_str())) 
        {
            ed::Suspend();
            LOGI("[HandleNodeToolBar] Open NodeSettingDialog for %" PRI_node, FMT_node(node));
            m_NodeSettingDialog.Open(node);
            ed::Resume();
        }
        if (ImGui::IsItemHovered()) node->m_IconHovered = 2;
    }

    if (node->GetStyle() == NodeStyle::Group)
    {
        ImGui::SameLine(0);
        if (ImGui::Button((titlebar_icons[3] + "##" + std::to_string(node->m_ID)).c_str())) 
        {
            ed::Suspend();
            LOGI("[HandleNodeToolBar] Open NodeSavingDialog for %" PRI_node, FMT_node(node));
            File_Export(node);
            ed::Resume();
        }
        if (ImGui::IsItemHovered()) node->m_IconHovered = 3;
    }

    ImGui::PopStyleVar(3);
    ImGui::PopStyleColor(3);
    return textSizeButton * (icons + 2);
}

bool BluePrintUI::CheckNodeStyle(const Node* node, NodeStyle style)
{
    bool checked = false;
    DummyNode * dummy = nullptr;
    auto isDummy = node->GetStyle() == NodeStyle::Dummy;
    if (isDummy)
        dummy = (DummyNode *)node;
    checked = node->GetStyle() == style || (dummy ? dummy->m_style == style : false);
    return checked;
}

void BluePrintUI::DrawNodes()
{
    if (!m_Document)
        return;
    const auto iconSize = ImVec2(ImGui::GetTextLineHeight(), ImGui::GetTextLineHeight());
    m_DebugOverlay->Begin();
    Node* need_clone_node = nullptr;
    // Commit all nodes to editor
    // Handling Comment/Group Node
    for (auto& node : m_Document->m_Blueprint.GetNodes())
    {
        auto isDummy = node->GetStyle() == NodeStyle::Dummy;
        auto isGroup = CheckNodeStyle(node, NodeStyle::Group);
        auto isGrouped = node->m_GroupID != 0;
        if (!CheckNodeStyle(node, NodeStyle::Comment) && !CheckNodeStyle(node, NodeStyle::Group))
            continue;
        const float commentAlpha = 0.75f;
        node->m_IconHovered = -1;
        ImGui::PushStyleVar(ImGuiStyleVar_Alpha, commentAlpha);
        //ed::PushStyleColor(ed::StyleColor_NodeBg, m_StyleColors[BluePrintStyleColor_GroupBg]);
        if (isDummy)
        {
            ed::PushStyleColor(ed::StyleColor_NodeBorder, m_StyleColors[BluePrintStyleColor_DummyBorder]);
        }
        else
        {
            ed::PushStyleColor(ed::StyleColor_NodeBorder, m_StyleColors[BluePrintStyleColor_Border]);
        }
        ed::BeginNode(node->m_ID);
        // Comment/Group node layout:
        //
        // [ Comment ]                         |     [ Group ]                              |
        // +-----------------------------------+     +--------------------------------------+
        // | Title                  iC iD iS   |     | Title                    is iC iD iS |
        // | +-----------[ Dummy ]-----------+ |     | +-----------[ Dummy ]--------------+ |
        // |                                   |     || i Pin |                    | Pin o ||
        // |                                   |     || i Pin |                    | Pin o ||
        // |            [ Content ]            |     |    .        [ Content ]         .    |
        // |                                   |     |    .                            .    |
        // |                                   |     || i Pin |                    | Pin o ||
        // +-----------------------------------+     +--------------------------------------+
        // PS: iS = Setting Icon, iC = Clone Icon, iD = Delete Icon, is = Save Icon
        ImGui::BeginVertical("content");
        // Show title if node has one.
        auto nodeName = !isDummy ? node->GetName() : ((DummyNode *)node)->m_name + "*load fail*";
        float title_height = 0;
        float title_width = 0;
        if (!nodeName.empty())
        {
            const float titleTextWidth = ImGui::CalcTextSize(nodeName.c_str()).x;
            const float titleTextHeight = ImGui::CalcTextSize(nodeName.c_str()).y;
            const float textSizeButton = ImGui::CalcTextSize(titlebar_icons[0].c_str()).x;
            const float dummyWidth = titleTextWidth + textSizeButton * 5 + 10;
            ImGui::PushStyleVar(ImGuiStyleVar_TexGlyphShadowOffset, ImVec2(2.0, 2.0));
            ImGui::PushStyleVar(ImGuiStyleVar_TexGlyphOutlineWidth, 1.0);
            ImGui::PushStyleColor(ImGuiCol_TexGlyphOutline, ImVec4(0.5, 0.5, 1.0, 1.0));
            ImGui::Dummy(ImVec2(dummyWidth, 10));
            ImGui::BeginHorizontal("horizontal");
            ImGui::Spring(1);
            ImFont* font = HeaderFont();
            if (font) ImGui::PushFont(font);
            ImGui::TextUnformatted(nodeName.data());
            if (font) ImGui::PopFont();
            ImGui::Spring(1);
            ImGui::EndHorizontal();
            ImGui::Dummy(ImVec2(dummyWidth, 10));
            title_height = titleTextHeight + 20;
            title_width = dummyWidth;
            ImGui::PopStyleVar(2);
            ImGui::PopStyleColor(1);
        }
        ImGui::EndVertical();
        if (!isDummy) title_width += DrawNodeToolBar(node, &need_clone_node);
        auto inPinPosMin = ed::GetNodePosition(node->m_ID); inPinPosMin.x += 8; inPinPosMin.y += title_height + 16;
        auto groupSize  = ed::GetGroupSize(node->m_ID);
        if (groupSize.x == 0)
            groupSize.x = title_width;
        ed::Group(groupSize);
        auto outPinPosMin = ed::GetNodePosition(node->m_ID); outPinPosMin.x += groupSize.x - 16; outPinPosMin.y += title_height + 16;

        if (isGroup)
        {
            node->Update();
            auto drawList = ImGui::GetWindowDrawList();
            auto num_inpin = node->GetInputPins().size();
            if (num_inpin > 0)
            {
                // Input pin layout:
                //
                //     +-[1]---+
                //     |       |
                //    [X] Icon |
                //     |       |
                //     +-------+
                auto inPinPosMax = inPinPosMin + ImVec2(24, num_inpin * (iconSize.y + 4) + 4);
                drawList->AddRectFilled(
                    inPinPosMin,
                    inPinPosMax,
                    ImGui::GetColorU32(m_StyleColors[BluePrintStyleColor_GroupBg]), 8.0f);
                auto PinMin = inPinPosMin + ImVec2(4, 4);
                for (auto& pin : node->GetInputPins())
                {
                    auto PinMax = PinMin + iconSize;
                    // draw shadow pin
                    if (pin->m_Type == PinType::Flow)
                    {
                        auto spin = pin->GetLink(&m_Document->m_Blueprint);
                        if (spin)
                        {
                            ed::BeginPin(spin->m_ID, ed::PinKind::Output);
                            ed::PinPivotAlignment(ImVec2(1.0f, 0.5f));
                            ed::PinRect(PinMin, PinMax);
                            DrawIcon(drawList, PinMin, PinMax,
                                    PinTypeToIconType(spin->GetType()),
                                    false,
                                    ImColor(ImVec4(0, 0, 0, 0)),
                                    ImColor(ImVec4(0, 0, 0, 0)));
                            ed::EndPin();
                        }
                    }
                    else
                    {
                        if (pin->m_LinkFrom.size() == 1)
                        {
                            auto spin = m_Document->m_Blueprint.GetPinFromID(pin->m_LinkFrom[0]);
                            if (spin)
                            {
                                ed::BeginPin(spin->m_ID, ed::PinKind::Output);
                                ed::PinPivotAlignment(ImVec2(1.0f, 0.5f));
                                ed::PinRect(PinMin, PinMax);
                                DrawIcon(drawList, PinMin, PinMax,
                                        PinTypeToIconType(spin->GetType()),
                                        false,
                                        ImColor(ImVec4(0, 0, 0, 0)),
                                        ImColor(ImVec4(0, 0, 0, 0)));
                                ed::EndPin();
                            }
                        }
                    }
                    // draw bridge pin
                    bool link_outside = false;
                    if (pin->m_Type == PinType::Flow)
                        link_outside = pin->m_LinkFrom.size() > 0;
                    else
                        link_outside = pin->m_Link != 0;
                    ed::BeginPin(pin->m_ID, ed::PinKind::Input);
                    ed::PinPivotAlignment(ImVec2(1.0f, 0.5f));
                    ed::PinRect(PinMin, PinMax);
                    DrawIcon(drawList, PinMin, PinMax,
                            PinTypeToIconType(pin->GetType()),
                            link_outside,
                            ImColor(PinTypeToColor(this, pin->GetValueType())),
                            ImColor(ImVec4(0, 0, 0, 0)));
                    ed::EndPin();

                    m_DebugOverlay->DrawInputPin(this, *pin);
                    PinMin += ImVec2(0, iconSize.y + 4);
                    //ImGui::Debug_DrawItemRect();
                }
            }
            // Output pin layout:
            //
            //    +-[1]---+
            //    |       |
            //    | Icon [X]
            //    |       |
            //    +-------+
            auto num_outpin = node->GetOutputPins().size();
            if (num_outpin > 0)
            {
                auto outPinPosMax = outPinPosMin + ImVec2(24, num_outpin * (16 + 4) + 4);
                drawList->AddRectFilled(
                    outPinPosMin,
                    outPinPosMax,
                    ImGui::GetColorU32(m_StyleColors[BluePrintStyleColor_GroupBg]), 8.0f);
                auto PinMin = outPinPosMin + ImVec2(4, 4);
                for (auto& pin : node->GetOutputPins())
                {
                    auto PinMax = PinMin + iconSize;
                    // draw shadow pin
                    if (pin->m_Type == PinType::Flow)
                    {
                        if (pin->m_LinkFrom.size() == 1)
                        {
                            auto spin = m_Document->m_Blueprint.GetPinFromID(pin->m_LinkFrom[0]);
                            if (spin)
                            {
                                ed::BeginPin(spin->m_ID, ed::PinKind::Input);
                                ed::PinPivotAlignment(ImVec2(0.0f, 0.5f));
                                ed::PinRect(PinMin, PinMax);
                                DrawIcon(drawList, PinMin, PinMax,
                                        PinTypeToIconType(spin->GetType()),
                                        false,
                                        ImColor(ImVec4(0, 0, 0, 0)),
                                        ImColor(ImVec4(0, 0, 0, 0)));
                                ed::EndPin();
                            }
                        }
                    }
                    else
                    {
                        auto spin = pin->GetLink(&m_Document->m_Blueprint);
                        if (spin)
                        {
                            ed::BeginPin(spin->m_ID, ed::PinKind::Input);
                            ed::PinPivotAlignment(ImVec2(0.0f, 0.5f));
                            ed::PinRect(PinMin, PinMax);
                            DrawIcon(drawList, PinMin, PinMax,
                                    PinTypeToIconType(spin->GetType()),
                                    false,
                                    ImColor(ImVec4(0, 0, 0, 0)),
                                    ImColor(ImVec4(0, 0, 0, 0)));
                            ed::EndPin();
                        }
                    }
                    // draw bridge pin
                    bool link_outside = false;
                    if (pin->m_Type == PinType::Flow)
                        link_outside = pin->m_Link != 0;
                    else
                        link_outside = pin->m_LinkFrom.size() > 0;
                    ed::BeginPin(pin->m_ID, ed::PinKind::Output);
                    ed::PinPivotAlignment(ImVec2(0.2f, 0.5f));
                    ed::PinRect(PinMin, PinMax);
                    DrawIcon(drawList, PinMin, PinMax,
                            PinTypeToIconType(pin->GetType()),
                            link_outside,
                            ImColor(PinTypeToColor(this, pin->GetValueType())),
                            ImColor(ImVec4(0, 0, 0, 0)));
                    ed::EndPin();
                    m_DebugOverlay->DrawOutputPin(this, *pin);
                    PinMin += ImVec2(0, iconSize.y + 4);
                    //ImGui::Debug_DrawItemRect();
                }
            }
        }
        ed::EndNode();
#if DEBUG_NODE_DRAWING
        ImGui::Debug_DrawItemRect();
#endif
        ed::PopStyleColor();
        ImGui::PopStyleVar();

        // Draw Title zoom out
        if (ed::BeginGroupHint(node->m_ID))
        {
            auto bgAlpha = static_cast<int>(ImGui::GetStyle().Alpha * 255);
            auto min = ed::GetGroupMin();
            ImGui::SetCursorScreenPos(min - ImVec2(-8, ImGui::GetTextLineHeightWithSpacing() + 4));
            ImGui::BeginGroup();
            ImFont* font = HeaderFont();
            if (font) ImGui::PushFont(font);
            ImGui::TextUnformatted(nodeName.data());
            if (font) ImGui::PopFont();
            ImGui::EndGroup();
            auto drawList = ed::GetHintBackgroundDrawList();
            auto hintBounds      = ed::Detail::ImGui_GetItemRect();
            auto hintFrameBounds = ed::Detail::ImRect_Expanded(hintBounds, 8, 4);
            drawList->AddRectFilled(
                hintFrameBounds.GetTL(),
                hintFrameBounds.GetBR(),
                IM_COL32(255, isDummy ? 0 : 255, isDummy ? 0 : 255, 64 * bgAlpha / 255), 4.0f);
            drawList->AddRect(
                hintFrameBounds.GetTL(),
                hintFrameBounds.GetBR(),
                IM_COL32(255, isDummy ? 0 : 255, isDummy ? 0 : 255, 128 * bgAlpha / 255), 4.0f);
        }
        ed::EndGroupHint();

        m_DebugOverlay->DrawNode(this, *node);
    }

    // Handling Default and SimpleNode
    for (auto& node : m_Document->m_Blueprint.GetNodes())
    {
        auto isDummy = node->GetStyle() == NodeStyle::Dummy;
        auto isGrouped = node->m_GroupID != 0;
        if (!CheckNodeStyle(node, NodeStyle::Default) && !CheckNodeStyle(node, NodeStyle::Simple))
            continue;
        node->m_IconHovered = -1;
        if (isDummy)
        {
            ed::PushStyleColor(ed::StyleColor_NodeBorder,    ImColor(255, 32,  32, 200));
        }
#if DEBUG_GROUP_NODE
        else if (isGrouped)
        {
            ed::PushStyleColor(ed::StyleColor_NodeBorder,    ImColor(32, 255,  32, 200));
        }
#endif
        ed::BeginNode(node->m_ID);
        // Default node layout:                         Simple node layout:
        //
        // +-----------------------------------+         +-----------------------------------+
        // | Title               iC  iD  iS    |         | | i Pin |               | Pin o | |
        // | +-----------[ Dummy ]-----------+ |         | | i Pin |               | Pin o | |
        // | +---------------+   +-----------+ |         | |   .   |               | Pin o | |
        // | | i Pin         |   |   Out B o | |         | |   .   |    Tile       |   .   | |
        // | | i Pin <Value> |   |   Out A o | |         | |   .   |               |   .   | |
        // | | i Pin         |   |           | |         | | i Pin |               |   .   | |
        // | +---------------+   +-----------+ |         | | i Pin |               | Pin o | |
        // +-----------------------------------+         +-----------------------------------+
        // PS: iS = Setting Icon, iC = Clone Icon, iD= Delete Icon
        // Show title if node has one.
        float dummy_width = 40;
        auto nodeName = !isDummy ? node->GetName() : 
                        !CheckNodeStyle(node, NodeStyle::Simple) ? ((DummyNode *)node)->m_name + "*load fail*" : "*err*";
        if (!nodeName.empty() && !CheckNodeStyle(node, NodeStyle::Simple))
        {
            auto headerBackgroundRenderer = ImGui::ItemBackgroundRenderer([node, this](ImDrawList* drawList)
            {
                auto isDummy = node->GetStyle() == NodeStyle::Dummy;
                auto border   = ed::GetStyle().NodeBorderWidth;
                auto rounding = ed::GetStyle().NodeRounding;
                auto nodeStart = ed::GetNodePosition(node->m_ID);
                auto nodeSize  = ed::GetNodeSize(node->m_ID);
                auto itemMin = ImGui::GetItemRectMin();
                auto itemMax = ImGui::GetItemRectMax();
                itemMin   = nodeStart;
                itemMin.x = itemMin.x + border - 0.5f;
                itemMin.y = itemMin.y + border - 0.5f;
                itemMax.x = nodeStart.x + nodeSize.x - border + 0.5f;
                itemMax.y = itemMax.y + ImGui::GetStyle().ItemSpacing.y + 0.5f;
                drawList->AddRectFilled(itemMin, itemMax, ImColor(isDummy ? m_StyleColors[BluePrintStyleColor_TitleBgDummy] : m_StyleColors[BluePrintStyleColor_TitleBg]), rounding, ImDrawCornerFlags_Top);
                auto size = ImVec2(8.0f, 8.0f);
                auto pos = itemMin + ImVec2(6, (itemMax.y - itemMin.y) / 2 - size.y / 2);
                if (ImGui::BulletToggleButton("##set_break_point", &node->m_BreakPoint, pos, size))
                {
                    ed::SetNodeChanged(node->m_ID);
                }
                //ImGui::Debug_DrawItemRect();
            });
            ImGui::PushStyleVar(ImGuiStyleVar_TexGlyphShadowOffset, ImVec2(2.0, 2.0));
            ImGui::PushStyleVar(ImGuiStyleVar_TexGlyphOutlineWidth, 1.0);
            ImGui::PushStyleColor(ImGuiCol_TexGlyphOutline, ImVec4(0.5, 0.5, 1.0, 1.0));
            ImGui::Dummy(ImVec2(0.1f, 0.f)); ImGui::SameLine(0);
            ImFont* font = HeaderFont();
            if (font) ImGui::PushFont(font);
            ImGui::TextUnformatted(nodeName.data(), nodeName.data() + nodeName.size());
            if (font) ImGui::PopFont();
            ImGui::PopStyleColor(1);
            ImGui::PopStyleVar(2);
            const float titleTextSize = ImGui::CalcTextSize(nodeName.c_str()).x;
            if (!isDummy)
            {
                float iconSize = DrawNodeToolBar(node, &need_clone_node);
                dummy_width = titleTextSize + iconSize;
            }
            else
            {
                dummy_width = titleTextSize;
            }
        }

        ImGui::Dummy(ImVec2(dummy_width, 0.0f)); // For minimum node width

        ImGui::Grid layout;
        layout.Begin(node->m_ID, CheckNodeStyle(node, NodeStyle::Simple) || node->CustomLayout() ? 3 : 2, dummy_width);
        layout.SetColumnAlignment(0.0f);
        // Draw column with input pins.
        for (auto& pin : node->GetInputPins())
        {
            // Add a bit of spacing to separate pins and make value not cramped
            ImGui::Spacing();
            // Input pin layout:
            //
            //     +-[1]---+-[2]------+-[3]----------+
            //     |       |          |              |
            //    [X] Icon | Pin Name | Value/Editor |
            //     |       |          |              |
            //     +-------+----------+--------------+
            ed::BeginPin(pin->m_ID, ed::PinKind::Input);
            // [X] - Tell editor to put pivot point in the middle of
            //       the left side of the pin. This is the point
            //       where link will be hooked to.
            //
            //       By default pivot is in pin center point which
            //       does not look good for blueprint nodes.
            ed::PinPivotAlignment(ImVec2(0.0f, 0.5f));
            // [1] - Icon
            Icon(iconSize,
                PinTypeToIconType(pin->GetType()),
                m_Document->m_Blueprint.HasPinAnyLink(*pin),
                pin->m_Flags & PIN_FLAG_EXPORTED,
                pin->m_Flags & PIN_FLAG_PUBLICIZED,
                PinTypeToColor(this, pin->GetValueType()));

            // [2] - Show pin name if it has one. Custom layout hidden name?
            if (!pin->m_Name.empty() && !CheckNodeStyle(node, NodeStyle::Simple) && !node->CustomLayout())
            {
                ImGui::SameLine();
                ImGui::TextUnformatted(pin->m_Name.data(), pin->m_Name.data() + pin->m_Name.size());
            }
            // [3] - Show value/editor when pin is not linked to anything
            if (!m_Document->m_Blueprint.HasPinAnyLink(*pin) && !CheckNodeStyle(node, NodeStyle::Simple) && !node->CustomLayout())
            {
                ImGui::SameLine();
                DrawPinValueWithEditor(*pin);
            }
            
            ed::EndPin();
            // [Debug Overlay] Show value of the pin if node is currently executed
            m_DebugOverlay->DrawInputPin(this, *pin);
            layout.NextRow();
        }
        if (CheckNodeStyle(node, NodeStyle::Simple))
        {
            auto nodeSize  = ed::GetNodeSize(node->m_ID);
            float font_size = ImGui::GetFontSize();
            layout.SetColumnAlignment(0.5f);
            layout.NextColumn();
            if (node->GetInputPins().size() > 1 || node->GetOutputPins().size() > 1)
                ImGui::Dummy(ImVec2(0, (nodeSize.y - font_size * 2) / 4));
            ImFont* font = HeaderFont();
            if (font) ImGui::PushFont(font);
            ImGui::TextUnformatted(nodeName.data());
            if (font) ImGui::PopFont();
        }
        else if (node->CustomLayout())
        {
            layout.SetColumnAlignment(0.5f);
            layout.NextColumn();
            float zoom = ed::GetCurrentZoom();
            ImVec2 origin = ed::GetCurrentOrigin();
            if (node->DrawCustomLayout(ImGui::GetCurrentContext(), zoom, origin))
                ed::SetNodeChanged(node->m_ID);
        }
        layout.SetColumnAlignment(1.0f);
        layout.NextColumn();
        // Draw column with output pins.
        for (auto& pin : node->GetOutputPins())
        {
            // Add a bit of spacing to separate pins and make value not cramped
            ImGui::Spacing();
            // Output pin layout:
            //
            //    +-[1]------+-[2]---+
            //    |          |       |
            //    | Pin Name | Icon [X]
            //    |          |       |
            //    +----------+-------+
            ed::BeginPin(pin->m_ID, ed::PinKind::Output);
            // [X] - Tell editor to put pivot point in the middle of
            //       the right side of the pin. This is the point
            //       where link will be hooked to.
            //
            //       By default pivot is in pin center point which
            //       does not look good for blueprint nodes.
            ed::PinPivotAlignment(ImVec2(1.0f, 0.5f));
            // [1] - Show pin name if it has one. Custom layout hidden name?
            if (!pin->m_Name.empty() && !CheckNodeStyle(node, NodeStyle::Simple) && !node->CustomLayout())
            {
                ImGui::TextUnformatted(pin->m_Name.data(), pin->m_Name.data() + pin->m_Name.size());
                ImGui::SameLine();
            }
            // [2] - Show icon
            Icon(iconSize,
                PinTypeToIconType(pin->GetType()),
                m_Document->m_Blueprint.HasPinAnyLink(*pin),
                pin->m_Flags & PIN_FLAG_EXPORTED,
                pin->m_Flags & PIN_FLAG_PUBLICIZED,
                PinTypeToColor(this, pin->GetValueType()));
            ed::EndPin();
            // [Debug Overlay] Show value of the pin if node is currently executed
            m_DebugOverlay->DrawOutputPin(this, *pin);
            layout.NextRow();
        }
        layout.End();

#if DEBUG_NODE_DRAWING
        ImGui::Debug_DrawItemRect();
#endif
        ed::EndNode();
        if (isDummy)
            ed::PopStyleColor(1);
#if DEBUG_GROUP_NODE
        else if (isGrouped)
            ed::PopStyleColor(1);
#endif
#if DEBUG_NODE_DRAWING
        ImGui::Debug_DrawItemRect();
#endif
        // [Debug Overlay] Show cursor over node
        m_DebugOverlay->DrawNode(this, *node);
    }

    // Commit all links to editor
    auto pins = m_Document->m_Blueprint.GetPins();
    for (auto pin : pins)
    {
        if (!pin->m_Link)
        {
            if (!(pin->m_Flags & PIN_FLAG_LINKED)) pin->m_LinkFrom.clear();
            continue;
        }

        auto link = pin->GetLink(&m_Document->m_Blueprint);
        if (!link)
        {
            pin->m_Link = 0;
            pin->m_LinkPin = nullptr;
            continue;
        }
        else
        {
            pin->m_LinkPin = link;
        }

        if (std::find(pins.begin(), pins.end(), link) == pins.end())
        {
            pin->m_Link = 0;
            pin->m_LinkPin = nullptr;
            continue;
        }
        
        // To keep things simple, link id is same as pin id.
        // check link is between bridge and shadow
        //bool inner_link = pin->IsMappedPin() && link->IsMappedPin() && pin->m_MappedPin && pin->m_MappedPin == link->m_MappedPin;
        //ed::Link(pin->m_ID, pin->m_ID, pin->m_Link, (inner_link ? ImVec4(0, 0, 0,  0) : PinTypeToColor(this, pin->GetValueType())), 1.5); // Maybe add to setting
        ed::Link(pin->m_ID, pin->m_ID, pin->m_Link, PinTypeToColor(this, pin->GetValueType()), 3.0); // Maybe add to setting
        pin->m_Flags |= PIN_FLAG_LINKED;
        link->m_Flags |= PIN_FLAG_LINKED;
        if (std::find(link->m_LinkFrom.begin(), link->m_LinkFrom.end(), pin->m_ID) == link->m_LinkFrom.end())
        {
            link->m_LinkFrom.push_back(pin->m_ID);
        }
    }

    // Handle clone node
    if (need_clone_node)
    {
        ed::Suspend();
        LOGI("[HandleNodeToolBar] Clone from %" PRI_node, FMT_node(need_clone_node));
        auto nodeStart = ed::GetNodePosition(need_clone_node->m_ID);
        auto clone_node = m_Document->m_Blueprint.CloneNode(need_clone_node, m_OverlayLogger);
        ed::SetNodePosition(clone_node->m_ID, ImVec2(nodeStart.x + 40, nodeStart.y + 80));
        ed::Resume();
    }
    bool isThreadExecuting = m_Document->m_Blueprint.IsExecuting();
    bool isThreadPaused = m_Document->m_Blueprint.IsPaused();
    if (isThreadExecuting && !isThreadPaused && m_DebugOverlay)
    {
        g_Mutex.lock();
        m_Document->m_Blueprint.SetContextMonitor(m_DebugOverlay->GetContextMonitor());
        m_Document->m_Blueprint.ShowFlow();
        m_Document->m_Blueprint.SetContextMonitor(nullptr);
        g_Mutex.unlock();
    }

    m_DebugOverlay->End();
}

void BluePrintUI::DrawInfoTooltip()
{
    if (!m_Document)
        return;
    if (!ed::IsActive())
        return;
    auto hoveredNode = m_Document->m_Blueprint.FindNode(static_cast<ID_TYPE>(ed::GetHoveredNode().Get()));
    auto hoveredPin  = m_Document->m_Blueprint.FindPin(static_cast<ID_TYPE>(ed::GetHoveredPin().Get()));
    if (!hoveredNode && hoveredPin)
        hoveredNode = hoveredPin->m_Node;
    
    auto pinTooltip = [](const char* label, const Pin& pin, bool showNode)
    {
        auto isDummy = pin.m_Node->GetStyle() == NodeStyle::Dummy;
        ImGui::Text("%s %s", label, !pin.m_Name.empty() ? pin.m_Name.c_str() : "");
        ImGui::Bullet(); ImGui::Text("        ID: 0x%08" PRIX32, pin.m_ID);
        if (pin.m_Link)
        {
            if (pin.m_Type == PinType::Flow)
                ImGui::Text("          ->: 0x%08" PRIX32, pin.m_Link);
            else
                ImGui::Text("          <-: 0x%08" PRIX32, pin.m_Link);
        }
        for (auto link_from : pin.m_LinkFrom)
        {
            if (pin.m_Type == PinType::Flow)
                ImGui::Text("          <-: 0x%08" PRIX32, link_from);
            else
                ImGui::Text("          ->: 0x%08" PRIX32, link_from);
        }
        if (pin.m_MappedPin)
        {
            ImGui::Text("      Mapped: 0x%08" PRIX32, pin.m_MappedPin);
        }

        if (showNode && pin.m_Node)
        {
            auto isDummy = pin.m_Node->GetStyle() == NodeStyle::Dummy;
            auto nodeName = !isDummy ? pin.m_Node->GetName() : ((DummyNode *)pin.m_Node)->m_name + "*load fail*";
            ImGui::Bullet(); ImGui::Text("      Node: %" PRI_sv, FMT_sv(nodeName));
        }
        ImGui::Bullet(); ImGui::Text("      Type: %s", PinTypeToString(pin.GetType()).c_str());
        ImGui::Bullet(); ImGui::Text("Value Type: %s", PinTypeToString(pin.GetValueType()).c_str());
        if (!isDummy && !pin.m_MappedPin && !pin.IsInput() && pin.GetValueType() == PinType::Mat)
        {
            ImGui::TextUnformatted("=============ImMat===========");
            auto pinValue = pin.GetValue();
            auto mat = pinValue.As<ImGui::ImMat>();
            if (!mat.empty())
            {
                ImGui::Text("        Width:%d", mat.w);
                ImGui::Text("       Height:%d", mat.h);
                ImGui::Text("     Channels:%d", mat.c);
                ImGui::Text("       Device:%s", mat.device == IM_DD_CPU ? "CPU" : 
                                                mat.device == IM_DD_VULKAN ? "Vulkan" :
                                                mat.device == IM_DD_VULKAN_IMAGE ? "Vulkan Image" : "Cuda");
                if (mat.device != 0)
                    ImGui::Text("          GPU:%d", mat.device_number);
                ImGui::Text("    Data type:%s", mat.type == IM_DT_INT8 ? "Int8" :
                                                mat.type == IM_DT_INT16 ? "Int16" :
                                                mat.type == IM_DT_INT32 ? "Int32" :
                                                mat.type == IM_DT_INT64 ? "Int64" :
                                                mat.type == IM_DT_FLOAT16 ? "Float 16" : 
                                                mat.type == IM_DT_FLOAT32 ? "Float" :
                                                mat.type == IM_DT_FLOAT64 ? "Double" : "Unknown");
                ImGui::Text("       Format:%s", mat.color_format == IM_CF_GRAY ? "Gray/Mono" :
                                                mat.color_format == IM_CF_BGR ? "BGR" :
                                                mat.color_format == IM_CF_ABGR ? "ABGR" :
                                                mat.color_format == IM_CF_BGRA ? "BGRA" :
                                                mat.color_format == IM_CF_RGB ? "RGB" :
                                                mat.color_format == IM_CF_ARGB ? "ARGB" :
                                                mat.color_format == IM_CF_RGBA ? "RGBA" :
                                                mat.color_format == IM_CF_YUV420 ? "YUV420" :
                                                mat.color_format == IM_CF_YUV422 ? "YUV422" :
                                                mat.color_format == IM_CF_YUV444 ? "YUV444" :
                                                mat.color_format == IM_CF_YUVA ? "YUVA" :
                                                mat.color_format == IM_CF_NV12 ? "NV12" : "Unknown");
            }
            else
            {
                ImGui::TextUnformatted("      *Empty*");
            }
            ImGui::TextUnformatted("=============================");
        }
        string flags;
        if (pin.IsMappedPin())
            flags += "mapped, ";
        if (pin.m_Flags & PIN_FLAG_EXPORTED)
            flags += "exported, ";
        if (pin.m_Flags & PIN_FLAG_PUBLICIZED)
            flags += "publicized, ";
        if (pin.IsLinked())
            flags += "linked, ";
        if (pin.IsInput())
            flags += "input, ";
        if (pin.IsOutput())
            flags += "output, ";
        if (pin.IsProvider())
            flags += "provider, ";
        if (pin.IsReceiver())
            flags += "receiver, ";
        if (!flags.empty())
            flags = flags.substr(0, flags.size() - 2);
        ImGui::Bullet(); ImGui::Text("   Flags: %s", flags.c_str());
    };

    ImGui::SetNextWindowBgAlpha(0.75f);
    if (hoveredNode)
    {
        auto isDummy = hoveredNode->GetStyle() == NodeStyle::Dummy;
        auto nodeTypeInfo = hoveredNode->GetTypeInfo();
        auto nodeName = !isDummy ? hoveredNode->GetName() : ((DummyNode *)hoveredNode)->m_name + "*load fail*";
        auto nodeTypeName = !isDummy ? nodeTypeInfo.m_Name : ((DummyNode *)hoveredNode)->m_type_name;
        auto nodeType = !isDummy ? hoveredNode->GetType() : ((DummyNode *)hoveredNode)->m_type;
        auto nodeStyle = !isDummy ? hoveredNode->GetStyle() : ((DummyNode *)hoveredNode)->m_style;
        auto nodeCatalog = !isDummy ? hoveredNode->GetCatalog() : ((DummyNode *)hoveredNode)->m_catalog;
        auto nodeVersion = hoveredNode->GetVersion();
        ed::Suspend();
        ImGui::BeginTooltip();
        if (hoveredNode->m_IconHovered >= 0)
        {
            switch (hoveredNode->m_IconHovered)
            {
                case 0: ImGui::TextUnformatted("Node Clone"); break;
                case 1: ImGui::TextUnformatted("Node Delete"); break;
                case 2: ImGui::TextUnformatted("Node Setting"); break;
                case 3: ImGui::TextUnformatted("Save Group"); break;
                default: break;
            }
        }
        else
        {
            if (hoveredPin)
            {
                if (ImGui::IsMouseDoubleClicked(0))
                {
                    LOGI("[Pin Event:] %" PRI_pin " be double clicked", FMT_pin(hoveredPin));
                    if (!hoveredPin->IsMappedPin())
                    {
                        if (hoveredPin->m_Flags & PIN_FLAG_PUBLICIZED)
                        {
                            hoveredPin->m_Flags &= ~PIN_FLAG_PUBLICIZED;
                        }
                        else
                        {
                            hoveredPin->m_Flags |= PIN_FLAG_PUBLICIZED;
                        }
                        ed::SetPinChanged(hoveredPin->m_ID);
                        m_Document->m_IsModified = true;
                    }
                }
                pinTooltip("Pin:", *hoveredPin, false);
                ImGui::Separator();
            }
            ImGui::Text("Node: %" PRI_sv, FMT_sv(nodeName));
            ImGui::Bullet(); ImGui::Text(" Node ID: 0x%08" PRIX32, hoveredNode->m_ID);
            ImGui::Bullet(); ImGui::Text(" Type ID: 0x%08" PRIX32, nodeTypeInfo.m_ID);
            ImGui::Bullet(); ImGui::Text("TypeName: %" PRI_sv, FMT_sv(nodeTypeName));
            ImGui::Bullet(); ImGui::Text(" Version: %" PRI_sv, FMT_sv(NodeVersionToString(nodeVersion)));
            ImGui::Bullet(); ImGui::Text("    Type: %s", NodeTypeToString(nodeType).c_str());
            ImGui::Bullet(); ImGui::Text("   Style: %s", NodeStyleToString(nodeStyle).c_str());
            ImGui::Bullet(); ImGui::Text(" Catalog: %s", nodeCatalog.c_str());
            ImGui::Bullet(); ImGui::Text("   Z-Pos: %.1f", ed::GetNodeZPosition(hoveredNode->m_ID));
            if (hoveredNode->m_GroupID != 0)
            {
                ImGui::Bullet(); ImGui::Text(" Grouped: 0x%08" PRIX32, hoveredNode->m_GroupID);
            }
            if (m_Document->m_Blueprint.IsExecuting())
            {
                ImGui::Bullet(); ImGui::Text("    Hits: %s", std::to_string(hoveredNode->m_Hits).c_str());
                std::ostringstream oss;
                oss << std::setprecision(hoveredNode->m_Tick > 1000 ? 6 : 3) << (hoveredNode->m_Tick > 1000000 ? hoveredNode->m_Tick / 1000000.0 :
                                        hoveredNode->m_Tick > 1000 ? hoveredNode->m_Tick / 1000.0 :
                                        hoveredNode->m_Tick);
                std::string tick_text = oss.str() + (hoveredNode->m_Tick > 1000000 ? "s" : hoveredNode->m_Tick > 1000 ? "ms" : "us");
                ImGui::Bullet(); ImGui::Text("   Ticks: %s", tick_text.c_str());
            }
        }
        ImGui::EndTooltip();
        ed::Resume();
    }
    else if (auto hoveredLinkId = ed::GetHoveredLink())
    {
        ed::PinId firstPinId, secondPinId;
        ed::GetLinkPins(hoveredLinkId, &firstPinId, &secondPinId);
        // inverse flow pin order since we create link using sample mode
        Pin * startPin = nullptr;
        Pin * endPin = nullptr;
        auto firstPin = m_Document->m_Blueprint.FindPin(static_cast<ID_TYPE>(firstPinId.Get()));
        auto secondPin = m_Document->m_Blueprint.FindPin(static_cast<ID_TYPE>(secondPinId.Get()));
        if (firstPin && secondPin)
        {
            if (firstPin->GetType() == PinType::Flow && secondPin->GetType() == PinType::Flow)
            {
                startPin = firstPin;
                endPin = secondPin;
            }
            else
            {
                startPin = secondPin;
                endPin = firstPin;
            }
            ed::Suspend();
            ImGui::BeginTooltip();
            ImGui::Text("Link ID: 0x%08" PRIX32, startPin->m_ID);
            ImGui::Text("Type: %s", PinTypeToString(startPin->GetValueType()).c_str());
            ImGui::Separator();
            pinTooltip("Start Pin:", *startPin, true);
            ImGui::Separator();
            pinTooltip("End Pin:", *endPin, true);
            ImGui::EndTooltip();
            ed::Resume();
        }
    }
}

void BluePrintUI::ShowDialogs()
{
    if (!m_Document)
        return;
    ed::Suspend();
    m_ContextMenu.Show(*this);
    m_NodeContextMenu.Show(*this);
    m_PinContextMenu.Show(*this);
    m_LinkContextMenu.Show(*this);
    m_NodeDeleteDialog.Show(*this);
    m_NodeCreateDialog.Show(*this);
    m_NodeSettingDialog.Show(*this);
    ed::Resume();
}

void BluePrintUI::FileDialogs()
{
    if (!m_Document)
        return;
    auto& io = ImGui::GetIO();
    ImVec2 modal_center(io.DisplaySize.x * 0.5f, io.DisplaySize.y * 0.5f);
    ImVec2 maxSize = ImVec2((float)io.DisplaySize.x, (float)io.DisplaySize.y);
    ImVec2 minSize = maxSize * 0.5f;
    if (m_FileDialog.Display("##OpenFileDlgKey", ImGuiWindowFlags_NoCollapse, minSize, maxSize))
    {
        if (m_FileDialog.IsOk())
        {
            string error;
            auto filePathName = m_FileDialog.GetFilePathName();
            if (!File_Open(filePathName, &error) && !error.empty())
            {
                LOGE("%s", error.c_str());
            }
        }
        m_FileDialog.Close();
    }
    if (m_FileDialog.Display("##SaveFileDlgKey", ImGuiWindowFlags_NoCollapse, minSize, maxSize))
	{
        if (m_FileDialog.IsOk())
		{
            auto filePathName = m_FileDialog.GetFilePathName();
            if (!File_SaveAsEx(filePathName))
            {
                LOGE("Save file failed %s", filePathName.c_str());
            }
            else
            {
                m_Document->SetPath(filePathName);
                auto mostRecentlyOpenFiles = GetMostRecentlyOpenFileList();
                mostRecentlyOpenFiles.Add(filePathName);
            }
        }
        m_FileDialog.Close();
    }
    if (m_FileDialog.Display("##SaveGroupDlgKey", ImGuiWindowFlags_NoCollapse, minSize, maxSize))
    {
        if (m_FileDialog.IsOk())
		{
            GroupNode * node = (GroupNode *)m_FileDialog.GetUserDatas();
            auto filePathName = m_FileDialog.GetFilePathName();
            if (node)
            {
                node->SaveGroup(filePathName);
            }
        }
        m_FileDialog.Close();
    }
    if (m_FileDialog.Display("##ImportGroupDlgKey", ImGuiWindowFlags_NoCollapse, minSize, maxSize))
    {
        if (m_FileDialog.IsOk())
        {
            string error;
            auto filePathName = m_FileDialog.GetFilePathName();
            ImVec2 * pos = (ImVec2 *)m_FileDialog.GetUserDatas();
            if (!File_Import(filePathName, *pos, &error) && !error.empty())
            {
                LOGE("%s", error.c_str());
            }
        }
        m_FileDialog.Close();
    }
}

Node* BluePrintUI::ShowNewNodeMenu(ImVec2 popupPosition)
{
    Node* node = nullptr;
    if (!m_Document)
        return node;
    static string filter_string = "";
    ImGui::PushStyleVar(ImGuiStyleVar_FrameBorderSize, 1.0);
    if (ImGui::InputText(ICON_NODE_SEARCH "##search_string_value", (char*)filter_string.data(), filter_string.size() + 1, ImGuiInputTextFlags_CallbackEdit | ImGuiInputTextFlags_EnterReturnsTrue | ImGuiInputTextFlags_CallbackResize, [](ImGuiInputTextCallbackData* data) -> int
    {
        if (data->EventFlag == ImGuiInputTextFlags_CallbackResize)
        {
            auto& stringValue = *static_cast<string*>(data->UserData);
            ImVector<char>* my_str = (ImVector<char>*)data->UserData;
            IM_ASSERT(stringValue.data() == data->Buf);
            stringValue.resize(data->BufSize);
            data->Buf = (char*)stringValue.data();
        }
        else if (data->EventFlag == ImGuiInputTextFlags_CallbackEdit)
        {
            auto& stringValue = *static_cast<string*>(data->UserData);
            stringValue = std::string(data->Buf);
        }
        return 0;
    }, &filter_string))
    {
        filter_string.resize(strlen(filter_string.c_str()));
    }
    ImGui::PopStyleVar();
    ImGui::Separator();
    auto registryNode = m_Document->m_Blueprint.GetNodeRegistry()->GetTypes();
    auto registryCatalog = m_Document->m_Blueprint.GetNodeRegistry()->GetCatalogs();

    if (filter_string.size() > 0)
    {
        string low_case_filter_str = to_lower(filter_string);

        for (size_t i = 0; i < registryCatalog.size(); i++)
        {
            auto catalog = registryCatalog[i];
            std::vector<const NodeTypeInfo *> array;
            for (auto nodetype : registryNode)
            {
                if (nodetype->m_Catalog.compare("Dummy") != 0 && nodetype->m_Catalog.compare(catalog) == 0)
                    array.push_back(nodetype);
            }
            for (auto nodetype : array)
            {
                string low_case_node_type_name = to_lower(nodetype->m_NodeTypeName);
                if (low_case_node_type_name.find(low_case_filter_str) != string::npos)
                {
                    ImGui::Bullet();
                    if (ImGui::MenuItem(nodetype->m_NodeTypeName.c_str(), nullptr, false, true, nodetype->m_Type == NodeType::External ? ICON_NODE_DLL : nullptr))
                    {
                        auto transaction = m_Document->BeginUndoTransaction("CreateNode");
                        node = m_Document->m_Blueprint.CreateNode(nodetype->m_ID);
                        LOGI("[NodeCreate] %" PRI_node " created", FMT_node(node));
                        if (popupPosition.x == 0 || popupPosition.y == 0)
                        {
                            ImVec2 w_pos = ImGui::GetCursorPos();
                            ImVec2 c_pos = ImGui::GetWindowPos();
                            popupPosition = ImVec2(w_pos.x + c_pos.x, w_pos.y + c_pos.y);
                        }
                        auto nodePosition = ed::ScreenToCanvas(popupPosition);
                        ed::SetNodePosition(node->m_ID, nodePosition);
                        ed::SelectNode(node->m_ID);
                        if (node->GetType() == NodeType::External && 
                            node->NeedOverlayLogger())
                        {
                            node->SetLogger(m_Document->m_OverlayLogger);
                        }
                        transaction->AddAction("%" PRI_node " created", FMT_node(node));
                        m_isNewNodePopuped = false;
                        m_newNodeLinkPin = nullptr;
                    }
                }
            }
        }
    }
    else
    {
        for (size_t i = 0; i < registryCatalog.size(); i++)
        {
            auto catalog = registryCatalog[i];
            std::vector<const NodeTypeInfo *> array;
            for (auto nodetype : registryNode)
            {
                if (nodetype->m_Catalog.compare("Dummy") != 0 && nodetype->m_Catalog.compare(catalog) == 0)
                    array.push_back(nodetype);
                std::sort(array.begin(), array.end(),
                            [](const NodeTypeInfo * a, const NodeTypeInfo * b) {
                                return a->m_NodeTypeName < b->m_NodeTypeName;
                        });
            }
            if (array.size() > 0 && ImGui::BeginMenu(catalog.c_str()))
            {
                for (auto nodetype : array)
                {
                    ImGui::Bullet();
                    if (ImGui::MenuItem(nodetype->m_NodeTypeName.c_str(), nullptr, false, true, nodetype->m_Type == NodeType::External ? ICON_NODE_DLL : nullptr))
                    {
                        auto transaction = m_Document->BeginUndoTransaction("CreateNode");
                        node = m_Document->m_Blueprint.CreateNode(nodetype->m_ID);
                        LOGI("[NodeCreate] %" PRI_node " created", FMT_node(node));
                        if (popupPosition.x == 0 || popupPosition.y == 0)
                        {
                            ImVec2 w_pos = ImGui::GetCursorPos();
                            ImVec2 c_pos = ImGui::GetWindowPos();
                            popupPosition = ImVec2(w_pos.x + c_pos.x, w_pos.y + c_pos.y);
                        }
                        auto nodePosition = ed::ScreenToCanvas(popupPosition);
                        ed::SetNodePosition(node->m_ID, nodePosition);
                        ed::SelectNode(node->m_ID);
                        if (node->GetType() == NodeType::External && 
                            node->NeedOverlayLogger())
                        {
                            node->SetLogger(m_Document->m_OverlayLogger);
                        }
                        transaction->AddAction("%" PRI_node " created", FMT_node(node));
                        m_isNewNodePopuped = false;
                        m_newNodeLinkPin = nullptr;
                    }
                }
                ImGui::EndMenu();
            }
        }
    }

    return node;
}

void BluePrintUI::HandleCreateAction()
{
    if (!m_Document)
        return;

    ItemBuilder itemBuilder;
    if (!itemBuilder)
        return;

    m_isNewNodePopuped = false;
    m_newNodeLinkPin = nullptr;

    if (auto linkBuilder = itemBuilder.QueryNewLink())
    {
        auto startPin = m_Document->m_Blueprint.FindPin(static_cast<ID_TYPE>(linkBuilder->m_StartPinId.Get()));
        auto endPin   = m_Document->m_Blueprint.FindPin(static_cast<ID_TYPE>(linkBuilder->m_EndPinId.Get()));
        // Editor return pins in order draw by the user. It is up to the
        // user to determine if it is valid. In blueprints we accept only links
        // from receivers to providers. Other graph types may allow bi-directional
        // links between nodes and this ordering make this feature possible.
        if (endPin->IsReceiver() && startPin->IsProvider())
            ImSwap(startPin, endPin);
        if (auto canLinkResult = startPin->CanLinkTo(*endPin))
        {
            ed::Suspend();
            ImGui::BeginTooltip();
            ImGui::Text("Valid Link%s%s",
                canLinkResult.Reason().empty() ? "" : ": ",
                canLinkResult.Reason().empty() ? "" : canLinkResult.Reason().c_str());
            ImGui::Separator();
            ImGui::TextUnformatted("From:");
            ImGui::Bullet(); ImGui::Text("%" PRI_pin, FMT_pin(startPin));
            ImGui::Bullet(); ImGui::Text("%" PRI_node, FMT_node(startPin->m_Node));
            ImGui::TextUnformatted("To:");
            ImGui::Bullet(); ImGui::Text("%" PRI_pin, FMT_pin(endPin));
            ImGui::Bullet(); ImGui::Text("%" PRI_node, FMT_node(endPin->m_Node));
            ImGui::EndTooltip();
            ed::Resume();
            if (linkBuilder->Accept())
            {
                auto transaction = m_Document->BeginUndoTransaction("Create Link");
                if (startPin->LinkTo(*endPin))
                    LOGI("[HandleCreateAction] %" PRI_pin " linked with %" PRI_pin, FMT_pin(startPin), FMT_pin(endPin));
                else
                    transaction->Discard();
            }
        }
        else
        {
            ed::Suspend();
            ImGui::SetTooltip(
                "Invalid Link: %s",
                canLinkResult.Reason().c_str()
            );
            ed::Resume();
            linkBuilder->Reject();
        }
    }
    else if (auto nodeBuilder = itemBuilder.QueryNewNode())
    {
        // Arguably creation of node is simpler than a link.
        ed::Suspend();
        ImGui::SetTooltip("Create Node...");
        ed::Resume();
        // Node builder accept return true when user release mouse button.
        // When this happen we request CreateNodeDialog to open.
        if (nodeBuilder->Accept())
        {
            // Get node from which link was pulled (if any). After creating
            // node we will try to make link with first matching pin of the node.
            auto pin = m_Document->m_Blueprint.FindPin(static_cast<ID_TYPE>(nodeBuilder->m_PinId.Get()));
            ed::Suspend();
            LOGI("[HandleCreateAction] Open CreateNodeDialog");
            m_NodeCreateDialog.Open(pin);
            m_isNewNodePopuped = true;
            m_newNodeLinkPin = pin;
            ed::Resume();
        }
    }
}

void BluePrintUI::HandleDestroyAction()
{
    if (!m_Document)
        return;
    ItemDeleter itemDeleter;
    if (!itemDeleter)
        return;
    auto deferredTransaction = m_Document->GetDeferredUndoTransaction("Destroy Action");
    vector<Node*> nodesToDelete;
    uint32_t brokenLinkCount = 0;
    // Process all nodes marked for deletion
    while (auto nodeDeleter = itemDeleter.QueryDeletedNode())
    {
        deferredTransaction->Begin("Delete Item");
        auto node = m_Document->m_Blueprint.FindNode(static_cast<ID_TYPE>(nodeDeleter->m_NodeId.Get()));
        // Remove node, pass 'true' so links attached to node will also be queued for deletion.
        if (node && nodeDeleter->Accept(node->GetStyle() != NodeStyle::Group))
        {
            // Infor Node to handle delete before serv links
            node->OnNodeDelete();
            // Queue nodes for deletion. We need to serve links first to avoid crash.
            nodesToDelete.push_back(node);
        }
    }
    // Process all links marked for deletion
    while (auto linkDeleter = itemDeleter.QueryDeleteLink())
    {
        deferredTransaction->Begin("Delete Item");
        if (linkDeleter->Accept())
        {
            auto pins = m_Document->m_Blueprint.GetPins();
            auto startPin = m_Document->m_Blueprint.FindPin(static_cast<ID_TYPE>(linkDeleter->m_StartPinId.Get()));
            if (startPin != nullptr && startPin->IsLinked())
            {
                auto linkedPin = startPin->GetLink();
                if (std::find(pins.begin(), pins.end(), linkedPin) != pins.end())
                {
                    LOGI("[HandleDestroyAction] %" PRI_pin " unlinked from %" PRI_pin, FMT_pin(startPin), FMT_pin(linkedPin));
                    startPin->Unlink();
                    ++brokenLinkCount;
                }
            }
        }
    }
    // After links was removed, now it is safe to delete nodes.
    for (auto node : nodesToDelete)
    {
        LOGI("[HandleDestroyAction] %" PRI_node, FMT_node(node));
        m_Document->m_Blueprint.DeleteNode(node);
    }
    if (!nodesToDelete.empty() || brokenLinkCount)
    {
        LOGI("[HandleDestroyAction] %" PRIu32 " node%s deleted, %" PRIu32 " link%s broken",
            static_cast<uint32_t>(nodesToDelete.size()), nodesToDelete.size() != 1 ? "s" : "",
            brokenLinkCount, brokenLinkCount != 1 ? "s" : "");
    }
}

void BluePrintUI::HandleContextMenuAction()
{
    if (!m_Document)
        return;
    
    if (m_Document->m_Blueprint.IsExecuting() && !m_Document->m_Blueprint.IsPaused())
        return;

    if (ed::ShowBackgroundContextMenu())
    {
        ed::Suspend();
        LOGI("[HandleContextMenuAction] Show Background Context Menu");
        m_ContextMenu.Open();
        ed::Resume();
    }

    ed::NodeId contextNodeId;
    if (ed::ShowNodeContextMenu(&contextNodeId))
    {
        auto node = m_Document->m_Blueprint.FindNode(static_cast<uint32_t>(contextNodeId.Get()));

        ed::Suspend();
        LOGI("[HandleContextMenuAction] Open NodeContextMenu for %" PRI_node, FMT_node(node));
        m_NodeContextMenu.Open(node);
        ed::Resume();
    }

    ed::PinId contextPinId;
    if (ed::ShowPinContextMenu(&contextPinId))
    {
        auto pin = m_Document->m_Blueprint.FindPin(static_cast<uint32_t>(contextPinId.Get()));

        ed::Suspend();
        LOGI("[HandleContextMenuAction] Open PinContextMenu for %" PRI_pin, FMT_pin(pin));
        m_PinContextMenu.Open(pin);
        ed::Resume();
    }

    ed::LinkId contextLinkId;
    if (ed::ShowLinkContextMenu(&contextLinkId))
    {
        auto pin = m_Document->m_Blueprint.FindPin(static_cast<ID_TYPE>(contextLinkId.Get()));

        ed::Suspend();
        LOGI("[HandleContextMenuAction] Open LinkContextMenu for %" PRI_pin, FMT_pin(pin));
        m_LinkContextMenu.Open(pin);
        ed::Resume();
    }
}

bool BluePrintUI::File_IsOpen()
{
    return m_Document != nullptr;
}

bool BluePrintUI::File_IsModified()
{
    return m_Document->m_IsModified;
}

void BluePrintUI::File_MarkModified()
{
    if (m_Document->m_IsModified)
        return;

    m_Document->m_IsModified = true;
}

void BluePrintUI::InitFileDialog(const char * bookmark_path)
{
#ifdef USE_BOOKMARK
	// load bookmarks
	m_BookMarkPath = bookmark_path ? std::string(bookmark_path) : "";
	std::ifstream docFile(bookmark_path, std::ios::in);
	if (docFile.is_open())
	{
		std::stringstream strStream;
		strStream << docFile.rdbuf();//read the file
		m_FileDialog.DeserializeBookmarks(strStream.str());
		docFile.close();
	}
#endif
}

EntryPointNode* BluePrintUI::FindEntryPointNode()
{
    for (auto& node : m_Document->m_Blueprint.GetNodes())
    {
        if (node->GetTypeInfo().m_ID == EntryPointNode::GetStaticTypeInfo().m_ID)
        {
            return static_cast<EntryPointNode*>(node);
        }
    }

    return nullptr;
}

bool BluePrintUI::File_Open(std::string path, string* error)
{
    if (File_IsOpen())
    {
        m_Document->Save();
        ed::ClearSelection();
        m_Document->m_Blueprint.Clear();
    }
    if (m_Document->Load(path) != BP_ERR_NONE)
    {
        if (error)
        {
            ImGuiTextBuffer buffer;
            buffer.appendf("Failed to load blueprint from file \"%" PRI_sv "\".", FMT_sv(path));
            *error = buffer.c_str();
        }
        else
            LOGE("Failed to load blueprint from file \"%" PRI_sv "\".", FMT_sv(path));
        return false;
    }

    LOGI("[File] Open \"%" PRI_sv "\"", FMT_sv(path));
    auto mostRecentlyOpenFiles = GetMostRecentlyOpenFileList();
    mostRecentlyOpenFiles.Add(path);
    //m_Document->SetPath(path);
    m_Document->OnMakeCurrent();
    m_DebugOverlay->Init(&m_Document->m_Blueprint);
    return true;
}

bool BluePrintUI::File_Open()
{
    bool result = true;
    std::string filePathName;
    const char *filters = "Blue print file (*.json *.bp){.json,.bp,.JSON,.BP},.*";
    m_FileDialog.OpenModal("##OpenFileDlgKey", ICON_IGFD_FOLDER_OPEN " Open File", filters, ".", 1, nullptr, m_BookMarkPath.empty() ? ImGuiFileDialogFlags_None : ImGuiFileDialogFlags_ShowBookmark);
    return result;
}

bool BluePrintUI::File_Import(std::string path, ImVec2 pos, string* error)
{
    if (m_Document->Import(path, pos) != BP_ERR_NONE)
    {
        if (error)
        {
            ImGuiTextBuffer buffer;
            buffer.appendf("Failed to import group from file \"%" PRI_sv "\".", FMT_sv(path));
            *error = buffer.c_str();
        }
        else
            LOGE("Failed to import group from file \"%" PRI_sv "\".", FMT_sv(path));
        return false;
    }

    LOGI("[File] Import group\"%" PRI_sv "\"", FMT_sv(path));
    return true;
}

bool BluePrintUI::File_Import()
{
    bool result = true;
    std::string filePathName;
    const char *filters = "Group file (*.group *.gp){.group,.gp,.GROUP,.GP},.*";
    m_FileDialog.OpenModal("##ImportGroupDlgKey", ICON_IGFD_FOLDER_OPEN " Open File", filters, ".", 1, &m_PopupMousePos, m_BookMarkPath.empty() ? ImGuiFileDialogFlags_None : ImGuiFileDialogFlags_ShowBookmark);
    return result;
}

bool BluePrintUI::File_New()
{
    File_Close();
    ed::ClearSelection();
    m_Document->m_Blueprint.Clear();
    ed::NavigateToOrigin();
    CreateNewDocument();
    m_DebugOverlay->Init(&m_Document->m_Blueprint);
    return true;
}

bool BluePrintUI::File_SaveAsEx(std::string path)
{
    if (!File_IsOpen())
        return true;
    if (!m_Document->Save(path))
    {
        LOGE("Failed to save blueprint to file \"%" PRI_sv "\".", FMT_sv(path));
        return false;
    }
    m_Document->m_IsModified = false;
    LOGI("[File] Save \"%" PRI_sv "\".", FMT_sv(path));
    return true;
}

bool BluePrintUI::File_SaveAs()
{
    const char *filters = "Blue print file (*.json *.bp){.json,.bp,.JSON,.BP},.*";
    auto& io = ImGui::GetIO();
    ImVec2 modal_center(io.DisplaySize.x * 0.5f, io.DisplaySize.y * 0.5f);
    ImVec2 maxSize = ImVec2((float)io.DisplaySize.x, (float)io.DisplaySize.y);
	ImVec2 minSize = maxSize * 0.5f;
    m_FileDialog.OpenModal("##SaveFileDlgKey", ICON_IGFD_FOLDER_OPEN " Save File", filters, ".", 1, nullptr, ImGuiFileDialogFlags_ConfirmOverwrite | (m_BookMarkPath.empty() ? ImGuiFileDialogFlags_None : ImGuiFileDialogFlags_ShowBookmark));
    return true;
}

bool BluePrintUI::File_Save()
{
    if (!m_Document->m_Path.empty())
        return File_SaveAsEx(m_Document->m_Path);
    else
        return File_SaveAs();
}

bool BluePrintUI::File_Close()
{
    // TODO::Dicky Do we need close file?
    if (!File_IsOpen())
        return true;
    bool result = true;
    if (File_IsModified())
    {
        File_Save();
    }
    LOGI("[File] Close");
    return result;
}

bool BluePrintUI::File_Exit()
{
    // TODO::Dicky Do we need Exit
    LOGI("Quit");
    return false;
}

bool BluePrintUI::Edit_Undo()
{
    bool ret = false;
    if (m_Document)
    {
        ret = m_Document->Undo();
        for (auto node : m_Document->m_Blueprint.GetNodes())
        {
            if (node->GetType() == NodeType::External && 
                node->NeedOverlayLogger())
            {
                node->SetLogger(m_OverlayLogger);
            }
        }
        m_DebugOverlay->Init(&m_Document->m_Blueprint);
    }
    return ret;
}

bool BluePrintUI::Edit_Redo()
{
    return m_Document ? m_Document->Redo() : false;
}

bool BluePrintUI::Edit_Cut()
{
    m_ClipBoard.clear();
    auto selectedNodes = GetSelectedNodes(m_Document->m_Blueprint);
    ed::ClearSelection();
    for (auto node : selectedNodes)
    {
        auto clip = ClipNode(node);
        m_ClipBoard.push_back(clip);
        LOGI("[Edit]: Cut Node %s", clip.m_Name.c_str());
        ed::DeleteNode(node->m_ID);
    }
    m_Document->m_IsModified = true;
    return selectedNodes.size() > 0;
}

bool BluePrintUI::Edit_Copy()
{
    m_ClipBoard.clear();
    auto nodes = GetSelectedNodes(m_Document->m_Blueprint);
    for (auto node : nodes)
    {
        auto clip = ClipNode(node);
        m_ClipBoard.push_back(clip);
        LOGI("[Edit]: Copy Node %s", node->GetName().c_str());
    }
    return nodes.size();
}

bool BluePrintUI::Edit_Paste()
{
    ed::ClearSelection();
    for (auto clip : m_ClipBoard)
    {
        auto clone_node = m_Document->m_Blueprint.CreateNode(clip.m_NodeInfo.m_ID);
        
        ed::SetNodePosition(clone_node->m_ID, ImVec2(clip.m_Pos.x + 40, clip.m_Pos.y + 80));
        ed::SetNodeSize(clone_node->m_ID, clip.m_Size);
        ed::SetGroupSize(clone_node->m_ID, clip.m_GroupSize);
        ed::SelectNode(clone_node->m_ID, true);
        clone_node->SetName(clip.m_Name);
        if (clone_node->GetType() == NodeType::External && 
            clone_node->NeedOverlayLogger())
        {
            clone_node->SetLogger(m_OverlayLogger);
        }
        LOGI("[Edit]: Paste Node %s", clip.m_Name.c_str());
    }
    return m_ClipBoard.size() > 0;
}

bool BluePrintUI::Edit_Duplicate()
{
    auto nodes = GetSelectedNodes(m_Document->m_Blueprint);
    ed::ClearSelection();
    for (auto node : nodes)
    {
        auto nodeStart = ed::GetNodePosition(node->m_ID);
        auto nodeSize = ed::GetNodeSize(node->m_ID);
        auto groupSize = ed::GetGroupSize(node->m_ID);
        auto clone_node = m_Document->m_Blueprint.CloneNode(node);
        if (!clone_node)
            continue;
        ed::SetNodePosition(clone_node->m_ID, ImVec2(nodeStart.x + 40, nodeStart.y + 80));
        ed::SetNodeSize(clone_node->m_ID, nodeSize);
        ed::SetGroupSize(clone_node->m_ID, groupSize);
        ed::SelectNode(clone_node->m_ID, true);
        LOGI("[Edit]: Clone Node 0x%08" PRIX32, clone_node->m_ID);
    }
    return nodes.size() > 0;
}

bool BluePrintUI::Edit_Delete()
{
    auto selectedNodes = GetSelectedNodes(m_Document->m_Blueprint);
    ed::ClearSelection();
    for (auto node : selectedNodes)
    {
        ed::DeleteNode(node->m_ID);
        LOGI("[Edit]: Delete Node 0x%08" PRIX32, node->m_ID);
    }
    m_Document->m_IsModified = true;
    return selectedNodes.size() > 0;
}

bool BluePrintUI::Edit_Unlink()
{
    auto selectedLinks = GetSelectedLinks(m_Document->m_Blueprint);
    ed::ClearSelection();
    for (auto selectedLink : selectedLinks)
    {
        ed::DeleteLink(selectedLink->m_ID);
        LOGI("[Edit]: Remove Link 0x%08" PRIX32, selectedLink->m_ID);
    }
    m_Document->m_IsModified = true;
    return selectedLinks.size() > 0;
}

bool BluePrintUI::Edit_Setting()
{
    return false; // TODO::Dicky
}

bool BluePrintUI::View_ShowFlow()
{
    if (!m_Document)
        return false;

    m_Document->m_Blueprint.ShowFlow();
    
    return true;
}

bool BluePrintUI::View_ShowMeters()
{
    if (!m_Document)
        return false;

    ed::TriggerShowMeters();
    return true;
}

bool BluePrintUI::View_ZoomToContent()
{
    if (m_Document)
    {
        ed::NavigateToContent();
        return true;
    }
    return false;
}

bool BluePrintUI::View_ZoomToSelection()
{
    if (m_Document)
    {
        ed::NavigateToSelection(true);
        return true;
    }
    return false;
}

bool BluePrintUI::View_NavigateBackward()
{
    return false; // TODO::Dicky
}

bool BluePrintUI::View_NavigateForward()
{
    return false; // TODO::Dicky
}

bool BluePrintUI::Blueprint_Stop()
{
    if (!m_Document)
        return false;
    m_Document->m_Blueprint.Stop();
    return true;
}

bool BluePrintUI::Blueprint_Run()
{
    if (!m_Document)
        return false;
    auto entryNode = FindEntryPointNode();
    auto result = m_Document->m_Blueprint.Execute(*entryNode);
    if (result == StepResult::Done)
        LOGI("Execution: Running");
    else if (result == StepResult::Error)
    {
        LOGI("Execution: Failed at step %" PRIu32, m_Document->m_Blueprint.StepCount());
        return false;
    }
    return true;
}

bool BluePrintUI::Blueprint_Pause()
{
    if (!m_Document)
        return false;
    auto result = m_Document->m_Blueprint.Pause();
    LOGI("Execution: Paused at step %" PRIu32, m_Document->m_Blueprint.StepCount());
    return true;
}

bool BluePrintUI::Blueprint_Next()
{
    if (!m_Document)
        return false;
    auto result = m_Document->m_Blueprint.Next();

    ed::PushStyleVar(ed::StyleVar_FlowMarkerDistance, 30.0f);
    ed::PushStyleVar(ed::StyleVar_FlowDuration, 1.0f);
    m_Document->m_Blueprint.ShowFlow();
    ed::PopStyleVar(2);

    return true;
}

bool BluePrintUI::Blueprint_Current()
{
    if (!m_Document)
        return false;
    auto result = m_Document->m_Blueprint.Current();

    ed::PushStyleVar(ed::StyleVar_FlowMarkerDistance, 30.0f);
    ed::PushStyleVar(ed::StyleVar_FlowDuration, 1.0f);
    m_Document->m_Blueprint.ShowFlow();
    ed::PopStyleVar(2);

    return true;
}

bool BluePrintUI::Blueprint_BreakPoint()
{
    if (!m_Document)
        return false;
    auto selectedNodes = GetSelectedNodes(m_Document->m_Blueprint);
    for (auto node : selectedNodes)
    {
        if (node->m_BreakPoint)
        {
            node->SetBreakPoint(false);
            LOGI("Execution: delete breakpoint 0x%08" PRIX32, node->m_ID);
        }
        else
        {
            node->SetBreakPoint(true);
            LOGI("Execution: Set breakpoint 0x%08" PRIX32, node->m_ID);
        }
    }
    return true;
}

bool BluePrintUI::File_Export(Node * group_node)
{
    const char *filters = "Group file (*.group *.gp){.group,.gp,.GROUP,.GP},.*";
    auto& io = ImGui::GetIO();
    ImVec2 modal_center(io.DisplaySize.x * 0.5f, io.DisplaySize.y * 0.5f);
    ImVec2 maxSize = ImVec2((float)io.DisplaySize.x, (float)io.DisplaySize.y);
	ImVec2 minSize = maxSize * 0.5f;
    m_FileDialog.OpenModal("##SaveGroupDlgKey", ICON_IGFD_FOLDER_OPEN " Save Group File", filters, ".", 1, group_node, ImGuiFileDialogFlags_ConfirmOverwrite | (m_BookMarkPath.empty() ? ImGuiFileDialogFlags_None : ImGuiFileDialogFlags_ShowBookmark));
    return true;
}

void BluePrintUI::UpdateActions()
{
    auto mostRecentlyOpenFiles = GetMostRecentlyOpenFileList();
    auto hasDocument = File_IsOpen();
    auto hasUndo     = hasDocument && !m_Document->m_Undo.empty();
    auto hasRedo     = hasDocument && !m_Document->m_Redo.empty();
    auto isModified  = hasDocument && File_IsModified();
    auto entryNode = FindEntryPointNode();
    bool hasBlueprint = true;
    bool hasEntryPoint = (entryNode != nullptr);
    bool isExecuting   = m_Document->m_Blueprint.CurrentNode() != nullptr;
    bool hasSelectedNode   = GetSelectedNodes(m_Document->m_Blueprint).size() > 0;
    bool hasSelectedLink   = GetSelectedLinks(m_Document->m_Blueprint).size() > 0;
    bool hasClipBoardNodes = m_ClipBoard.size() > 0;
    bool isThreadExecuting = m_Document->m_Blueprint.IsExecuting();
    bool isThreadPaused = m_Document->m_Blueprint.IsPaused();

    bool hasExportedLink = false;
    if (hasSelectedLink)
    {
        auto links = GetSelectedLinks(m_Document->m_Blueprint);
        for (auto pin : links)
        {
            if (pin->IsLinkedExportedPin())
            {
                hasExportedLink = true;
                break;
            }
        }
    }

    m_File_Open.SetEnabled(!isThreadExecuting);
    m_File_New.SetEnabled(!isThreadExecuting);
    m_File_Close.SetEnabled(hasDocument && !isThreadExecuting);
    m_File_SaveAs.SetEnabled(hasDocument && !isThreadExecuting);
    m_File_Save.SetEnabled(hasDocument && !isThreadExecuting);
    m_Edit_Undo.SetEnabled(hasUndo && (!isThreadExecuting || isThreadPaused));
    m_Edit_Redo.SetEnabled(hasRedo && (!isThreadExecuting || isThreadPaused));
    m_Edit_Cut.SetEnabled(hasDocument && hasSelectedNode && (!isThreadExecuting || isThreadPaused));
    m_Edit_Copy.SetEnabled(hasDocument && hasSelectedNode && (!isThreadExecuting || isThreadPaused));
    m_Edit_Paste.SetEnabled(hasDocument && hasClipBoardNodes && (!isThreadExecuting || isThreadPaused));
    m_Edit_Duplicate.SetEnabled(hasDocument && hasSelectedNode && (!isThreadExecuting || isThreadPaused));
    m_Edit_Delete.SetEnabled(hasDocument && hasSelectedNode && (!isThreadExecuting || isThreadPaused));
    m_Edit_Unlink.SetEnabled(hasDocument && hasSelectedLink && !hasExportedLink && (!isThreadExecuting || isThreadPaused));
    m_Edit_Setting.SetEnabled(hasDocument && (!isThreadExecuting || isThreadPaused));
    m_View_NavigateBackward.SetEnabled(hasDocument && false);
    m_View_NavigateForward.SetEnabled(hasDocument && false);
    m_View_ShowFlow.SetEnabled(hasDocument && (!isThreadExecuting || isThreadPaused));
    m_View_ZoomToContent.SetEnabled(hasBlueprint);
    m_View_ZoomToSelection.SetEnabled(hasBlueprint);
    m_Blueprint_Stop.SetEnabled(hasBlueprint && (isExecuting || isThreadExecuting));
    m_Blueprint_Run.SetEnabled(hasBlueprint && hasEntryPoint && (!isThreadExecuting || isThreadPaused));
    m_Blueprint_Pause.SetEnabled(hasBlueprint && hasEntryPoint && isThreadExecuting && !isThreadPaused);
#if defined(__EMSCRIPTEN__)
    m_Blueprint_Next.SetEnabled(hasBlueprint && hasEntryPoint && isExecuting);
#else
    m_Blueprint_Next.SetEnabled(hasBlueprint && hasEntryPoint && isThreadExecuting && isThreadPaused);
#endif
    m_Blueprint_Current.SetEnabled(hasBlueprint && hasEntryPoint && isThreadExecuting && isThreadPaused);
}

void BluePrintUI::ShowStyleEditor(bool* show)
{
    if (!ImGui::Begin("Edit Style", show))
    {
        ImGui::End();
        return;
    }
    //auto paneWidth = ImGui::GetContentRegionAvailWidth();
    float paneWidth = 600;
    auto& editorStyle = ed::GetStyle();
    ImGui::BeginHorizontal("Style buttons", ImVec2(paneWidth, 0), 1.0f);
    ImGui::TextUnformatted("Values");
    ImGui::Spring();
    if (ImGui::Button("Reset to defaults"))
        editorStyle = ed::Style();
    ImGui::EndHorizontal();
    ImGui::Spacing();
    ImGui::DragFloat4("Node Padding", &editorStyle.NodePadding.x, 0.1f, 0.0f, 40.0f);
    ImGui::DragFloat("Node Rounding", &editorStyle.NodeRounding, 0.1f, 0.0f, 40.0f);
    ImGui::DragFloat("Node Border Width", &editorStyle.NodeBorderWidth, 0.1f, 0.0f, 15.0f);
    ImGui::DragFloat("Hovered Node Border Width", &editorStyle.HoveredNodeBorderWidth, 0.1f, 0.0f, 15.0f);
    ImGui::DragFloat("Selected Node Border Width", &editorStyle.SelectedNodeBorderWidth, 0.1f, 0.0f, 15.0f);
    ImGui::DragFloat("Pin Rounding", &editorStyle.PinRounding, 0.1f, 0.0f, 40.0f);
    ImGui::DragFloat("Pin Border Width", &editorStyle.PinBorderWidth, 0.1f, 0.0f, 15.0f);
    ImGui::DragFloat("Link Strength", &editorStyle.LinkStrength, 1.0f, 0.0f, 500.0f);
    //ImVec2  SourceDirection;
    //ImVec2  TargetDirection;
    ImGui::DragFloat("Scroll Duration", &editorStyle.ScrollDuration, 0.001f, 0.0f, 2.0f);
    ImGui::DragFloat("Flow Marker Distance", &editorStyle.FlowMarkerDistance, 1.0f, 1.0f, 200.0f);
    ImGui::DragFloat("Flow Speed", &editorStyle.FlowSpeed, 1.0f, 1.0f, 2000.0f);
    ImGui::DragFloat("Flow Duration", &editorStyle.FlowDuration, 0.001f, 0.0f, 5.0f);
    //ImVec2  PivotAlignment;
    //ImVec2  PivotSize;
    //ImVec2  PivotScale;
    //float   PinCorners;
    //float   PinRadius;
    //float   PinArrowSize;
    //float   PinArrowWidth;
    ImGui::DragFloat("Group Rounding", &editorStyle.GroupRounding, 0.1f, 0.0f, 40.0f);
    ImGui::DragFloat("Group Border Width", &editorStyle.GroupBorderWidth, 0.1f, 0.0f, 15.0f);
    ImGui::Separator();
    static ImGuiColorEditFlags edit_mode = ImGuiColorEditFlags_RGB;
    ImGui::BeginHorizontal("Color Mode", ImVec2(paneWidth, 0), 1.0f);
    ImGui::TextUnformatted("Filter Colors");
    ImGui::Spring();
    ImGui::RadioButton("RGB", &edit_mode, ImGuiColorEditFlags_RGB);
    ImGui::Spring(0);
    ImGui::RadioButton("HSV", &edit_mode, ImGuiColorEditFlags_HSV);
    ImGui::Spring(0);
    ImGui::RadioButton("HEX", &edit_mode, ImGuiColorEditFlags_HEX);
    ImGui::EndHorizontal();
    static ImGuiTextFilter filter;
    filter.Draw("", paneWidth);
    ImGui::Spacing();
    for (int i = 0; i < ed::StyleColor_Count; ++i)
    {
        auto name = ed::GetStyleColorName((ed::StyleColor)i);
        if (!filter.PassFilter(name))
            continue;
        ImGui::ColorEdit4(name, &editorStyle.Colors[i].x, edit_mode);
    }
    ImGui::End();
}

void BluePrintUI::ShowToolbar(bool* show)
{
    auto& io = ImGui::GetIO();
    const float DISTANCE = 40.0f;
    static int corner = -1;
    ImGuiWindowFlags window_flags = ImGuiWindowFlags_NoDecoration | ImGuiWindowFlags_AlwaysAutoResize | ImGuiWindowFlags_NoFocusOnAppearing | ImGuiWindowFlags_NoNav;
    if (corner != -1)
    {
        window_flags |= ImGuiWindowFlags_NoMove;
        ImVec2 window_pos = ImVec2((corner & 1) ? io.DisplaySize.x - DISTANCE : DISTANCE, (corner & 2) ? io.DisplaySize.y - DISTANCE : DISTANCE);
        ImVec2 window_pos_pivot = ImVec2((corner & 1) ? 1.0f : 0.0f, (corner & 2) ? 1.0f : 0.0f);
        ImGui::SetNextWindowPos(window_pos, ImGuiCond_Always, window_pos_pivot);
    }
    ImGui::SetNextWindowBgAlpha(0.35f); // Transparent background
    ImGui::PushStyleColor(ImGuiCol_Button, m_StyleColors[BluePrintStyleColor_ToolButton]);
    ImGui::PushStyleColor(ImGuiCol_ButtonHovered, m_StyleColors[BluePrintStyleColor_ToolButtonHovered]);
    ImGui::PushStyleColor(ImGuiCol_ButtonActive, m_StyleColors[BluePrintStyleColor_ToolButtonActive]);
    ImGui::PushStyleVar(ImGuiStyleVar_TexGlyphShadowOffset, ImVec2(2.0, 2.0));
    if (ImGui::Begin("##floating_toolbar", show, window_flags))
    {
        auto toolbarAction = [](Action& action)
        {
            ImGui::ScopedDisableItem disableAction(!action.IsEnabled());
#if IMGUI_ICONS
            string title = action.GetIcon() + "##toolbar";
#else
            string title = action.GetName() + "##toolbar";
#endif
            if (ImGui::Button(title.c_str()))
            {
                action.Execute();
            }
        };
        ImGui::Dummy(ImVec2(20, 0));
        ImGui::SameLine();
        toolbarAction(m_File_Open); ImGui::ShowTooltipOnHover("%s", m_File_Open.GetName().c_str());
        ImGui::SameLine();
        toolbarAction(m_File_New); ImGui::ShowTooltipOnHover("%s", m_File_New.GetName().c_str());
        ImGui::SameLine();
        toolbarAction(m_File_Save); ImGui::ShowTooltipOnHover("%s", m_File_Save.GetName().c_str());
        ImGui::SameLine();
        toolbarAction(m_File_SaveAs); ImGui::ShowTooltipOnHover("%s", m_File_SaveAs.GetName().c_str());
        ImGui::SameLine();
        ImGui::SeparatorEx(ImGuiSeparatorFlags_Vertical);
        ImGui::SameLine();
        ImGui::SeparatorEx(ImGuiSeparatorFlags_Vertical);
        ImGui::SameLine();
        toolbarAction(m_Edit_Undo); ImGui::ShowTooltipOnHover("%s", m_Edit_Undo.GetName().c_str());
        ImGui::SameLine();
        toolbarAction(m_Edit_Redo); ImGui::ShowTooltipOnHover("%s", m_Edit_Redo.GetName().c_str());
        ImGui::SameLine();
        toolbarAction(m_Edit_Copy); ImGui::ShowTooltipOnHover("%s", m_Edit_Copy.GetName().c_str());
        ImGui::SameLine();
        toolbarAction(m_Edit_Paste); ImGui::ShowTooltipOnHover("%s", m_Edit_Paste.GetName().c_str());
        ImGui::SameLine();
        toolbarAction(m_Edit_Cut); ImGui::ShowTooltipOnHover("%s", m_Edit_Cut.GetName().c_str());
        ImGui::SameLine();
        toolbarAction(m_Edit_Duplicate); ImGui::ShowTooltipOnHover("%s", m_Edit_Duplicate.GetName().c_str());
        ImGui::SameLine();
        toolbarAction(m_Edit_Delete); ImGui::ShowTooltipOnHover("%s", m_Edit_Delete.GetName().c_str());
        ImGui::SameLine();
        toolbarAction(m_Edit_Unlink); ImGui::ShowTooltipOnHover("%s", m_Edit_Unlink.GetName().c_str());
        ImGui::SameLine();
        ImGui::SeparatorEx(ImGuiSeparatorFlags_Vertical);
        ImGui::SameLine();
        ImGui::SeparatorEx(ImGuiSeparatorFlags_Vertical);
        ImGui::SameLine();
        toolbarAction(m_View_ShowFlow); ImGui::ShowTooltipOnHover("%s", m_View_ShowFlow.GetName().c_str());
        ImGui::SameLine();
        toolbarAction(m_View_ZoomToContent); ImGui::ShowTooltipOnHover("%s", m_View_ZoomToContent.GetName().c_str());
        ImGui::SameLine();
        toolbarAction(m_View_ZoomToSelection); ImGui::ShowTooltipOnHover("%s", m_View_ZoomToSelection.GetName().c_str());
        ImGui::SameLine();
        ImGui::SeparatorEx(ImGuiSeparatorFlags_Vertical);
        ImGui::SameLine();
        ImGui::SeparatorEx(ImGuiSeparatorFlags_Vertical);
        ImGui::SameLine();
        toolbarAction(m_Blueprint_Run); ImGui::ShowTooltipOnHover("%s", m_Blueprint_Run.GetName().c_str());
        ImGui::SameLine();
        toolbarAction(m_Blueprint_Pause); ImGui::ShowTooltipOnHover("%s", m_Blueprint_Pause.GetName().c_str());
        ImGui::SameLine();
        toolbarAction(m_Blueprint_Next); ImGui::ShowTooltipOnHover("%s", m_Blueprint_Next.GetName().c_str());
        ImGui::SameLine();
        toolbarAction(m_Blueprint_Current); ImGui::ShowTooltipOnHover("%s", m_Blueprint_Current.GetName().c_str());
        ImGui::SameLine();
        toolbarAction(m_Blueprint_Stop); ImGui::ShowTooltipOnHover("%s", m_Blueprint_Stop.GetName().c_str());
        ImGui::SameLine();
        ImGui::SeparatorEx(ImGuiSeparatorFlags_Vertical);
        ImGui::SameLine();
        ImGui::SeparatorEx(ImGuiSeparatorFlags_Vertical);
        ImGui::SameLine();
        ImGui::Text("%d(%s)", m_Document->m_Blueprint.StepCount(), StepResultToString(m_Document->m_Blueprint.LastStepResult()));
        ImGui::SameLine();
        ImGui::Text("%.3fms/%.1fFPS", ImGui::GetIO().DeltaTime * 1000.f, ImGui::GetIO().Framerate);
        ImGui::SameLine();
        ImGui::Dummy(ImVec2(20, 0));
    }
    // TODO::ed::ShowBackgroundContextMenu will overwrite this popup
    if (ImGui::BeginPopupContextWindow())
    {
        if (ImGui::MenuItem("Custom",       NULL, corner == -1)) corner = -1;
        if (ImGui::MenuItem("Top-left",     NULL, corner == 0)) corner = 0;
        if (ImGui::MenuItem("Top-right",    NULL, corner == 1)) corner = 1;
        if (ImGui::MenuItem("Bottom-left",  NULL, corner == 2)) corner = 2;
        if (ImGui::MenuItem("Bottom-right", NULL, corner == 3)) corner = 3;
        ImGui::EndPopup();
    }
    ImGui::PopStyleVar(1);
    ImGui::PopStyleColor(3);
    ImGui::End();
}

} // namespace BluePrint
